<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeGild Working</title>
  <icon>https://www.gravatar.com/avatar/60e2b17bf7b75b6259656295d5ba33ae</icon>
  <subtitle>我去的地方没有雪</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://begild.top/"/>
  <updated>2018-12-04T15:10:05.970Z</updated>
  <id>http://begild.top/</id>
  
  <author>
    <name>BeGild</name>
    <email>yucangbao@126.com/1028366823@qq,com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树莓派-花生壳-内网穿透</title>
    <link href="http://begild.top/article/3ac023e7.html"/>
    <id>http://begild.top/article/3ac023e7.html</id>
    <published>2018-09-01T15:53:13.000Z</published>
    <updated>2018-12-04T15:10:05.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="远程访问树莓派"><a href="#远程访问树莓派" class="headerlink" title="远程访问树莓派"></a>远程访问树莓派</h2><p>树莓派一般都是接在路由器下面的，当然是内网啦，在外面的时候是访问不了的，这时候就需要<a href="http://service.oray.com/question/5571.html" target="_blank" rel="noopener">内网穿透</a>才能实现外网依然能够访问到树莓派。内网穿透的软件网上有很多，这里选择花生壳，貌似挺有名的。</p><h2 id="花生壳注册"><a href="#花生壳注册" class="headerlink" title="花生壳注册"></a>花生壳注册</h2><p>官网<a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a>.</p><ol><li>打开之后在右上角有登录注册。</li><li>点击注册，同意隐私政策，填写账号密码手机号，按照正常流程走就OK了。貌似后续是会提示你进行实名制的，嫌麻烦可以不用实名制拍照上传啥的,不操作这一步。</li><li>注册成功会送你一个免费的花生壳域名用作以后使用，你也可以免费注册一个自定义的壳域名，不过后缀是指定的。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F.png" alt=""></li></ol><h2 id="安装树莓派花生壳客户端"><a href="#安装树莓派花生壳客户端" class="headerlink" title="安装树莓派花生壳客户端"></a>安装树莓派花生壳客户端</h2><p>下载最新安装包<a href="https://hsk.oray.com/download" target="_blank" rel="noopener">https://hsk.oray.com/download</a>，选择树莓派下载。也可以通过SSH运行下面命令直接获得并安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/pi/Documents &amp;&amp; mkdir hskoray &amp;&amp; cd hskoray  //创建下载目录</span><br><span class="line">wget  https://hsk.oray.com/download/download?id=25 -O phddns_rapi.armhf.deb //下载</span><br><span class="line">sudo dpkg -i phddns_rapi.armhf.deb //安装</span><br></pre></td></tr></table></figure></p><p>安装完毕会输出SN码和默认的登录密码，这个需要保存一下SN码，之后添加设备需要用到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pi@BeGild_Raspi:~/Documents/hskoray $ sudo dpkg -i phddns_rapi_3.0.1.armhf.deb</span><br><span class="line">正在选中未选择的软件包 phddns。</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 129540 个文件和目录。)</span><br><span class="line">正准备解包 phddns_rapi_3.0.1.armhf.deb  ...</span><br><span class="line">正在解包 phddns (3.0.2) ...</span><br><span class="line">正在设置 phddns (3.0.2) ...</span><br><span class="line">2018-09-02 02:32:31     = Debug =       [http_call] attempt to connect server: rapi.ephapi.oray.net/device/register</span><br><span class="line">2018-09-02 02:32:31     = Debug =       [http_call] create new stream because alive streams is empty.</span><br><span class="line">2018-09-02 02:32:31     - Info  -       [http_call] connect server: rapi.ephapi.oray.net:443(121.40.234.27)</span><br><span class="line">  . Performing the SSL/TLS handshake...</span><br><span class="line"> ok</span><br><span class="line">  . Verifying peer X.509 certificate...</span><br><span class="line"> ok</span><br><span class="line">2018-09-02 02:32:32     - Info  -       register ok</span><br><span class="line">SN : RA***cac***4a4**</span><br><span class="line">fastcode=2a868****b29e267****be05ee803a5</span><br><span class="line">SN : RA***cac***4a4**</span><br><span class="line">2018-09-02 02:32:32     - Info  -       [Main] oraysl started as a daemon.</span><br><span class="line">Phddns Service install success.</span><br><span class="line"></span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">|             Oray PeanutHull Linux 3.0            |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">|  SN: RA***cac***4a4**   Default password: admin  |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">|    Remote Management Address http://b.oray.com   |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">正在处理用于 systemd (232-25+deb9u4) 的触发器 ...</span><br><span class="line">pi@BeGild_Raspi:~/Documents/hskoray $</span><br></pre></td></tr></table></figure></p><p>其余的相关功能命令大致如下，可以通过输入<code>phddns</code> 获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -r phddns //卸载花生壳</span><br><span class="line">phddns start（启动）| stop（停止）| restart（重启）</span><br><span class="line">phddns status（状态）| version（版本）|reset（重置）</span><br></pre></td></tr></table></figure></p><p>日志保存在<code>/var/log/phddns</code>目录下。官方的教程见<a href="http://service.oray.com/question/2680.html" target="_blank" rel="noopener">花生壳 3.0 for 树莓派 安装使用攻略</a></p><h2 id="绑定设备"><a href="#绑定设备" class="headerlink" title="绑定设备"></a>绑定设备</h2><p>绑定需要先登录远程管理设备页面。点击<a href="https://b.oray.com/" target="_blank" rel="noopener">https://b.oray.com/</a>，打开远程管理页面，输入刚生成的树莓派的SN码，输入默认密码admin进行登录。第一次登陆会让你完善信息填写手机号等信息。<br>登录之后会提示你这个是内部的账号需要和你刚注册的账号进行”绑定”。点击<code>立即切换</code>即可切换到登录界面,输入你注册的账号和密码登录,设备自然就归属到你的名下了。<br><a href="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A.png" target="_blank" rel="noopener"></a></p><h2 id="开通内网穿透"><a href="#开通内网穿透" class="headerlink" title="开通内网穿透"></a>开通内网穿透</h2><p>开通内网穿透体验版仅需6元，可以在绑定设备后在<a href="https://b.oray.com/forward/" target="_blank" rel="noopener">设备管理界面</a>点击左边侧栏的内网穿透进行开通.<br><img src="http://upload-cdn.oray.com/upload/help/1806/201806251335371098.png" alt=""><br>也可以在<a href="https://hsk.oray.com/" target="_blank" rel="noopener">首页</a>左下角点击进入开通页面开通.<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%BC%80%E9%80%9A%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.png" alt=""></p><h2 id="路由器打开DDNS"><a href="#路由器打开DDNS" class="headerlink" title="路由器打开DDNS"></a><del>路由器打开DDNS</del></h2><p>emmm我看别人的教程都没说要设置DDNS了，但是我的不设置的话就不成功。所以这里有待考究[2018.10.04]这里找客服咨询过来，不需要设置路由器 DDNS ，不仅如此，如果设置了DDNS花生壳会提示账号重复登录的问题，之前不成功的原因是因为需要一定的刷新(映射？)时间。</p><ul><li>设置过程就是在浏览器输入路由器管理地址，一般就是<code>192.168.1.0</code>或者<code>192.168.1.1</code>，输入管理员密码登录，我的是TPLINK WR855N，是支持DDNS的。</li><li>登录之后的页面里选择应用管理-&gt; DDNS 进入，在服务提供者选择花生壳，输入自己的账号和密码勾选自动登录然后登录就OK了。</li><li>对了这里建议使用路由器的IP和MAC地址绑定应用，将IP固定分配给树莓派，这样树莓派在内网的IP就固定了.<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/TPLINK%E8%AE%BE%E7%BD%AEDDNS.png" alt="">  </li></ul><h2 id="添加端口映射"><a href="#添加端口映射" class="headerlink" title="添加端口映射"></a>添加端口映射</h2><p>开通了端口映射之后，在端口映射页面右边会出现一个增加端口映射的按钮。点击即可添加.<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.png" alt=""></p><h2 id="注册免费的自定义壳域"><a href="#注册免费的自定义壳域" class="headerlink" title="注册免费的自定义壳域"></a>注册免费的自定义壳域</h2><p>注册了花生壳账号之后会给一个选一个自定义壳域名的机会。在设备管理页面点击侧边<code>我的域名</code>,左上角有个<code>注册壳域名</code>.点击之后进入注册界面，写一下自己喜欢的前缀在免费的后缀里选择一个，点击搜索，没有被别人注册的话就可以自注册了。<br>用这个壳域名添加映射同样可以使用。</p><h2 id="验证访问"><a href="#验证访问" class="headerlink" title="验证访问"></a>验证访问</h2><p>打开SSH软件，新建一个连接填写主机地址(添加映射的壳域名)，端口(花生壳为你分配的随机端口，在<a href="https://b.oray.com/" target="_blank" rel="noopener">设备管理页面</a>-&gt;内网穿透-&gt;映射列表-&gt;壳域名-&gt;后可以看到)，输入登录账号pi和你的树莓派密码即可，双击新建的连接，能连接成功就是通了的。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%85%AC%E7%BD%91SSH%E9%AA%8C%E8%AF%81.png" alt=""></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过上面的一系列步骤树莓派已经可以在外网被访问了，这里端口映射添加的是SSH指定的22端口，当然你也可以根据需要指定其他的端口，不过免费版本的只支持两个端口映射。经过使用，这个为你分配的临时端口其实时间挺长的，不会几小时就变一次，两三天都不变一次的。<br>可以下载官方的花生壳管理APP,<a href="https://hsk.oray.com/download/download?id=36" target="_blank" rel="noopener">Android</a>/<a href="https://hsk.oray.com/download/download?id=37" target="_blank" rel="noopener">IOS</a>进行管理和查看状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="树莓派" scheme="http://begild.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="花生壳" scheme="http://begild.top/tags/%E8%8A%B1%E7%94%9F%E5%A3%B3/"/>
    
      <category term="内网穿透" scheme="http://begild.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>树莓派|云服务器-MQTT环境搭建</title>
    <link href="http://begild.top/article/64c79d1b.html"/>
    <id>http://begild.top/article/64c79d1b.html</id>
    <published>2018-08-26T07:13:24.000Z</published>
    <updated>2018-12-04T15:08:10.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="树莓派之-MQTT-搭建"><a href="#树莓派之-MQTT-搭建" class="headerlink" title="树莓派之 MQTT 搭建"></a>树莓派之 MQTT 搭建</h2><p>每天出门总怀疑自己灯没关、空调没关，晚上睡觉的时候躺下才意识到灯没关、然而开关却理我特别远，这我可接受不了 2333 ，所以产生了这种刚需🤣，这里记录一下搭建<a href="https://baike.baidu.com/item/MQTT/3618851" target="_blank" rel="noopener">MQTT</a>环境的过程。<br><a id="more"></a></p><h2 id="搭建的两种方法"><a href="#搭建的两种方法" class="headerlink" title="搭建的两种方法"></a>搭建的两种方法</h2><ol><li>树莓派作为 MQTT 服务器，用花生壳映射端口( 6 块钱)可以供给外网访问，这个方法的话最便宜的方案吧，不过外网的端口是不固定的，如果被改变了就得打开花生壳管理器查看分配的公网端口，嫌麻烦的话可以买固定的端口，得差不多 100 块这样子。不过这两个都是永久的加起来 100 多一点。当然如果不嫌麻烦，那就只要 6 元了。结构大概就是这样子，23333 画的不太好将就看。<br>树莓派同时运行一个 MQTT 服务器和一个 MQTT 客户端。手机运行一个 MQTT 客户端，通过访问花生壳映射之后的域名和端口来访问内网的树莓派 MQTT 服务器进行通信。树莓派运行的 MQTT 客户端直接通过内网和服务器进行通信。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-EMQTT-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%A0%91%E8%8E%93%E6%B4%BEMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt="">  </li><li>云主机作为 MQTT 服务器，这个方案的话因为我之前买了腾讯云的服务器 120 一年，续了三年。闲置着也是没有用，所以利用了起来。这个方法的话比较容易实现，不折腾那些个什么内网穿透，但是钱也会多很多，不过云服务器有公网 IP 还有以后可以有很多利用的地方。大概的关系就是如下图，比较容易理解的吧还是，树莓派运行的客户端通过网络和云主机上的服务器进行通信，手机上的MQTT客户端同样如此。</li></ol><p><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-EMQTT-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt=""></p><p>MQTT 的服务器我选择使用的是开源的 EMQTT ,官方提供了很多系统的安装包，很容易搭建的，管理也很方便。官网见 <a href="http://emqtt.com/" target="_blank" rel="noopener">http://emqtt.com/</a>.树莓派作为服务器的话安装使用需要采用源码的方式进行编译安装。</p><h2 id="云主机作为MQTT服务器"><a href="#云主机作为MQTT服务器" class="headerlink" title="云主机作为MQTT服务器"></a>云主机作为MQTT服务器</h2><p>之前搞优惠活动的时候买的腾讯云的服务器，服务器的配置是 2G 内存 1Mbps 带宽 40GB 硬盘，跑这个绰绰有余。具体的购买流程就不说了，傻瓜式的，我选择的是 centos 7 作为系统，因为据说这个系统做服务器多？这个后续后悔了还可以免费改的。<br>买了服务器之后要<a href="https://www.yuntunpuzi.com/qcloud/178/" target="_blank" rel="noopener">设置安全组的规则</a>，我是把所有端口都打开了的(安全？不存在考虑的)，最起码要把 22 端口开放，因为这个是 SSH 登录要用的端口。完成初步的配置就可以用了。搞到服务器的密码就可以用账户 root + 密码进行 SSH 访问了。之后的都是用 SSH 进行配置的。SSH 软件的使用可以看之前写的树莓派安装系统和配置下的-&gt;<a href="http://begild.top/article/fd8be0b3.html">使用SSH进行树莓派的连接</a><br>接下来的操作都是在 centos 7系统的终端里运行的。  </p><ol><li><p>通过 rpm 安装包进行安装。(使用简单快捷)教程可以看<a href="http://emqtt.com/docs/v2/install.html#rpm" target="_blank" rel="noopener">这里</a>.    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install wget //安装下载工具这个应该都是预置了的</span><br><span class="line">yum install lksctp-tools  //安装Erlang/OTP R19依赖库</span><br><span class="line">wget http://emqtt.com/downloads/latest/centos7-rpm -O emqttd-centos7-x86_64.rpm //下载安装包</span><br><span class="line">rpm -ivh emqttd-centos7-x86_64.rpm //安装</span><br></pre></td></tr></table></figure><p>安装完成之后呢就可以运行了，是不是超级简单。通过下面的命令可以启动、停止、重启、查看状态整个 EMQTT 服务。这个方式安装，配置文件存放在<code>/etc/emqttd/</code>下的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start|stop|restart|status emqttd.service</span><br></pre></td></tr></table></figure></li><li><p>通用包方式安装。(绿色解压版)。教程可以看<a href="http://emqtt.com/docs/v2/install.html#linux" target="_blank" rel="noopener">这里</a>.绿色版嘛当然是要手动执行文件启动的啦。这个方式下的配置文件是存放在解压目录下的<code>etc</code>下,不在<code>/etc/emqttd/</code>下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://emqtt.com/downloads/latest/centos7 -O emqttd-centos7.zip //下载压缩包</span><br><span class="line">unzip emqttd-centos7.zip //解压安装</span><br><span class="line"></span><br><span class="line">cd 解压目录/emqttd</span><br><span class="line">./bin/emqttd console //运行控制台 ctrl+c退出</span><br><span class="line">./bin/emqttd start|stop|restart //后台守护进程方式</span><br></pre></td></tr></table></figure></li><li><p>访问服务器控制界面<br>Dashboard 插件可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)。EMQ 消息服务器默认加载 Dashboard 插件。<br>安装完成之后访问在浏览器地址栏输入 服务器IP:18083/ 即可访问网页端的控制界面，如下图所示。会提示你输入登录账户和密码，默认的账户是<code>admin</code> 密码是 <code>public</code>。登录之后点击侧边 <code>USER</code> 栏，可以看到 <code>admin</code> 账户点击 <code>Edit</code> 即可更改密码。页面右上角可以切换主题配色，语言。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-EMQTT-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%AA%E8%A1%A8%E7%9B%98.png" alt="">  </p></li><li><p>MQTT 服务器的配置。<br>无论通过何种方式安装都需要修改服务器的一些插件和配置文件才能为你所用。这里呢主要是配置客户端的登录服务器验证方式和客户端的ID等信息。<br>其认证方式如下，客户端接入服务器呢，需要进行用户名密码的认证，客户端ID的认证，如果你两个都不开(ignore)的话就是匿名认证。用户名的认证需要打开  <code>emq_auth_username</code> 插件。客户端ID的认证需要打开 <code>emq_auth_clientid</code> 插件。服务器默认打开匿名认证，我选择打开用户名密码认证，客户端ID认证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          ----------------           ----------------           ------------</span><br><span class="line">Client --&gt; | Username认证 | -ignore-&gt; | ClientID认证 | -ignore-&gt; | 匿名认证 |</span><br><span class="line">          ----------------           ----------------           ------------</span><br><span class="line">       |                         |                         |</span><br><span class="line">      \|/                       \|/                       \|/</span><br><span class="line"> allow | deny              allow | deny              allow | deny</span><br></pre></td></tr></table></figure><ul><li><p>添加配置列表-用户名/密码.<br>既然使能了用户名密码验证，当然是需要添加用户名和密码的啦，配置文件为 <code>emq_auth_username.conf</code>,在各自存放配置文件的目录下的<code>plugins</code>目录下。软件安装版为<code>/etc/emqttd/plugins/emq_auth_username.conf</code>。解压绿色版为<code>解压目录/emqttd/etc/plugins/emq_auth_username.conf</code>。  使用下面命令打开文件(自行学习vim)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/emqttd/plugins/emq_auth_username.conf   //软件安装版</span><br><span class="line">vim 解压目录/emqttd/etc/plugins/emq_auth_username.conf  //解压绿色版</span><br></pre></td></tr></table></figure><p>打开文件可以看到给了示例的模板，按照模板增加即可。 贴一个示例如下。修改之后保存就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##--------------------------------------------------------------------</span><br><span class="line">## Username Authentication Plugin</span><br><span class="line">##--------------------------------------------------------------------</span><br><span class="line">auth.user.1.username = BeGild_test</span><br><span class="line">auth.user.1.password = 123456</span><br><span class="line">auth.user.2.username = BeGild_test_1</span><br><span class="line">auth.user.2.password = 123456</span><br></pre></td></tr></table></figure></li><li><p>添加配置列表-客户端ID<br>既然使能了用客户端ID 验证，当然是需要添加客户端ID列表和密码的啦，配置文件为 <code>emq_auth_clientid.conf</code>,在各自存放配置文件的目录下的<code>plugins</code>目录下。软件安装版为<code>/etc/emqttd/plugins/emq_auth_clientid.conf</code>。解压绿色版为<code>解压目录/emqttd/etc/plugins/emq_auth_clientid.conf</code>。  使用下面命令打开文件(自行学习vim)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/emqttd/plugins/emq_auth_clientid.conf    //软件安装版</span><br><span class="line">vim 解压目录/emqttd/etc/plugins/emq_auth_clientid.conf   //解压绿色版</span><br></pre></td></tr></table></figure><p>打开文件可以看到给了示例的模板，按照模板增加即可。 贴一个示例如下。修改之后保存就好了。看起来和用户名密码是差不多的，他俩之间的对应关系还不太清楚，之后搞懂了会再更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##--------------------------------------------------------------------</span><br><span class="line">## ClientId Authentication Plugin</span><br><span class="line">##--------------------------------------------------------------------</span><br><span class="line">auth.client.1.clientid = test1</span><br><span class="line">auth.client.1.password = test1_pwd</span><br><span class="line">auth.client.2.clientid = test2</span><br><span class="line">auth.client.2.password = test2_pwd</span><br></pre></td></tr></table></figure></li><li><p>打开认证插件<br>插件打开可以点击网页的控制台侧边插件栏页面，可以看到很多插件第1,9个就是，点击右侧边启动按钮进行打开，打开成功就会变成绿色的<font color="#00cc00" size="3.7">运行中</font>。<br>启用插件，配置完成之后即可投入使用啦。EMQ2.0支持的认证插件有可以看<a href="http://emqtt.com/docs/v2/guide.html#id1" target="_blank" rel="noopener">这里</a>这些.</p></li></ul></li></ol><h2 id="树莓派作为-MQTT-服务器"><a href="#树莓派作为-MQTT-服务器" class="headerlink" title="树莓派作为 MQTT 服务器"></a>树莓派作为 MQTT 服务器</h2><p>树莓派作为 MQTT 服务器同样需要安装服务器的软件，不过只能通过源码编译安装的方式进行，编译源码依赖于 Erlang 工具，所以得走两步，安装编译工具，下载源码编译安装。</p><ol><li><p>安装 erlang 编译环境.emmmm 这个工具编译完毕之后就可以卸磨杀驴！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install erlang //安装 erlang</span><br><span class="line">sudo apt-get autoremove erlang //卸载 erlang</span><br></pre></td></tr></table></figure></li><li><p>挑一个自己喜欢的目录执行下面指令进行源码克隆和编译.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/emqtt/emq-relx.git</span><br><span class="line">cd emq-relx</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>待编译成功后会生成<code>_rel</code>目录存放生成的一系列可执行文件和配置文件等,执行下面语句执行控制台方式启动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd _rel/emqttd</span><br><span class="line">./bin/emqttd console</span><br></pre></td></tr></table></figure><p>可支持的指令和组合有如下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: emqttd &#123;start|start_boot &lt;file&gt;|foreground|stop|restart|reboot|pid|ping|console|console_clean|console_boot &lt;file&gt;|attach|remote_console|upgrade|escript|rpc|rpcterms|eval&#125;</span><br></pre></td></tr></table></figure></li><li><p>列一下常用指令正常的表现吧。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//这是控制台方式启动 EMQTT 会输出一些启动，运行的信息。</span><br><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/server/emq-relx/_rel/emqttd $ ./bin/emqttd console</span><br><span class="line">Exec: /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/erts-8.2.1/bin/erlexec -boot /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/releases/2.3.11/emqttd -mode embedded -boot_var ERTS_LIB_DIR /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/erts-8.2.1/../lib -mnesia dir &quot;/home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/data/mnesia/emq@127.0.0.1&quot; -config /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/data/configs/app.2018.08.30.15.18.31.config -args_file /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/data/configs/vm.2018.08.30.15.18.31.args -vm_args /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd/data/configs/vm.2018.08.30.15.18.31.args -- console</span><br><span class="line">Root: /home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd</span><br><span class="line">/home/pi/Documents/MQtt/server/emq-relx/_rel/emqttd</span><br><span class="line">Erlang/OTP 19 [erts-8.2.1] [source] [smp:4:4] [async-threads:32] [kernel-poll:true]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 30-Aug-2018::15:18:52 ===</span><br><span class="line">    alarm_handler: &#123;set,&#123;system_memory_high_watermark,[]&#125;&#125;</span><br><span class="line">starting emqttd on node &apos;emq@127.0.0.1&apos;</span><br><span class="line">emqttd ctl is starting...[ok]</span><br><span class="line">emqttd hook is starting...[ok]</span><br><span class="line">emqttd router is starting...[ok]</span><br><span class="line">emqttd pubsub is starting...[ok]</span><br><span class="line">emqttd stats is starting...[ok]</span><br><span class="line">emqttd metrics is starting...[ok]</span><br><span class="line">emqttd pooler is starting...[ok]</span><br><span class="line">emqttd trace is starting...[ok]</span><br><span class="line">emqttd client manager is starting...[ok]</span><br><span class="line">emqttd session manager is starting...[ok]</span><br><span class="line">emqttd session supervisor is starting...[ok]</span><br><span class="line">emqttd wsclient supervisor is starting...[ok]</span><br><span class="line">emqttd broker is starting...[ok]</span><br><span class="line">emqttd alarm is starting...[ok]</span><br><span class="line">emqttd mod supervisor is starting...[ok]</span><br><span class="line">emqttd bridge supervisor is starting...[ok]</span><br><span class="line">emqttd access control is starting...[ok]</span><br><span class="line">emqttd system monitor is starting...[ok]</span><br><span class="line">emqttd 2.3.11 is running now</span><br><span class="line">Eshell V8.2.1  (abort with ^G)</span><br><span class="line">(emq@127.0.0.1)1&gt; Load emq_mod_presence module successfully.</span><br><span class="line">dashboard:http listen on 0.0.0.0:18083 with 4 acceptors.</span><br><span class="line">mqtt:tcp listen on 127.0.0.1:11883 with 4 acceptors.</span><br><span class="line">mqtt:tcp listen on 0.0.0.0:1883 with 16 acceptors.</span><br><span class="line">mqtt:ws listen on 0.0.0.0:8083 with 4 acceptors.</span><br><span class="line">mqtt:ssl listen on 0.0.0.0:8883 with 16 acceptors.</span><br><span class="line">mqtt:wss listen on 0.0.0.0:8084 with 4 acceptors.</span><br><span class="line">mqtt:api listen on 0.0.0.0:8080 with 4 acceptors.</span><br><span class="line"></span><br><span class="line">(emq@127.0.0.1)1&gt;</span><br><span class="line">//这是后台守护进程方式启动 EMQTT 服务器 启动有点慢，稍等稍等。</span><br><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/server/emq-relx/_rel/emqttd $ ./bin/emqttd start</span><br><span class="line">emqttd 2.3.11 is started successfully!</span><br><span class="line">//这是停止当前启动了的 EMQTT 服务器</span><br><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/server/emq-relx/_rel/emqttd $ ./bin/emqttd stop</span><br><span class="line">ok</span><br><span class="line">//这是重启已经启动了的 EMQTT 服务器</span><br><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/server/emq-relx/_rel/emqttd $ ./bin/emqttd restart</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>如果运行的时候出现下面错误,那你一定是运行的目录不对，一定要是 <code>_rel/emqttd/</code>目录下才是编译生成的目录，才可以运行 EMQTT 服务器！！！。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/server/emq-relx/bin $ ./emqttd restart</span><br><span class="line">./emqttd: 20: ./emqttd: runner_log_dir: not found</span><br></pre></td></tr></table></figure></p><ol><li>访问服务器控制界面。<br>在浏览器输入树莓派IP:18083，输入账号 admin 和默认密码 public 进入管理控制界面，其余操作和以云主机作为 MQTT 服务器上一样，打开两个认证插件即可。</li><li>MQTT 服务器的配置。<br>配置文件的修改参照上面以云主机为 MQTT 服务器的配置例子，只是配置文件在<code>_rel/emqttd/etc/</code>下面。</li><li>花生壳外网访问的配置。参照<a href="http://begild.top/article/3ac023e7.html">树莓派-花生壳-内网穿透</a>中的添加端口映射1883到外网。</li></ol><h2 id="安装-MQTT-客户端依赖库"><a href="#安装-MQTT-客户端依赖库" class="headerlink" title="安装 MQTT 客户端依赖库"></a>安装 MQTT 客户端依赖库</h2><p>安装好服务器可以使用了，就进入客户端代码的编写了呀，客户端在树莓派上运行一个，在手机上运行一个。</p><ol><li><p>在树莓派上使用 MQTT 客户端当然是要安装 MQTT 客户端的库呀，首先运行下面几条命令做一些编译前的准备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home/pi/Documents &amp;&amp; mkdir emqtt //创建一个mqtt的目录</span><br><span class="line">cd emqtt &amp;&amp; git clone https://github.com/eclipse/paho.mqtt.c.git  //克隆mqtt客户端源码</span><br><span class="line">sudo apt-get install build-essential gcc make cmake cmake-gui cmake-curses-gui //安装编译工具</span><br><span class="line">sudo apt-get install fakeroot fakeroot devscripts dh-make lsb-release //安装软件包构建工具</span><br><span class="line">sudo apt-get install libssl-dev //安装openssl</span><br><span class="line">sudo apt-get install doxygen graphviz //安装文档生成工具</span><br></pre></td></tr></table></figure></li><li><p>编译 MQTT 客户端源码。官方的教程看这里<a href="https://github.com/eclipse/paho.mqtt.c" target="_blank" rel="noopener">paho.mqtt.c</a>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd paho.mqtt.c &amp;&amp; make //转到源码目录进行编译</span><br><span class="line">/***********等待漫长的时间没有报错就OK了*********************/</span><br><span class="line">sudo make html //编译生成文档</span><br><span class="line">sudo make install //安装到系统</span><br></pre></td></tr></table></figure><p>备注:需要编译生成文档不然安装时会提示如下错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install -m 644 build/output/doc/MQTTClient/man/man3/MQTTClient.h.3 /usr/local/share/man/man3</span><br><span class="line">install: 无法获取&apos;build/output/doc/MQTTClient/man/man3/MQTTClient.h.3&apos; 的文件状态(stat): 没有那个文件或目录</span><br><span class="line">Makefile:273: recipe for target &apos;install&apos; failed</span><br><span class="line">make: [install] Error 1 (ignored)</span><br><span class="line">install -m 644 build/output/doc/MQTTAsync/man/man3/MQTTAsync.h.3 /usr/local/share/man/man3</span><br><span class="line">install: 无法获取&apos;build/output/doc/MQTTAsync/man/man3/MQTTAsync.h.3&apos; 的文件状态(stat): 没有那个文件或目录</span><br><span class="line">Makefile:273: recipe for target &apos;install&apos; failed</span><br><span class="line">make: [install] Error 1 (ignored)</span><br></pre></td></tr></table></figure><p>安装成功显示如下信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/paho.mqtt.c $ sudo make install</span><br><span class="line">mkdir -p build/output/samples</span><br><span class="line">mkdir -p build/output/test</span><br><span class="line">echo OSTYPE is Linux</span><br><span class="line">OSTYPE is Linux</span><br><span class="line">mkdir -p /usr/local/include</span><br><span class="line">install -m 644  build/output/libpaho-mqtt3c.so.1.0 /usr/local/lib</span><br><span class="line">install -m 644  build/output/libpaho-mqtt3cs.so.1.0 /usr/local/lib</span><br><span class="line">install -m 644  build/output/libpaho-mqtt3a.so.1.0 /usr/local/lib</span><br><span class="line">install -m 644  build/output/libpaho-mqtt3as.so.1.0 /usr/local/lib</span><br><span class="line">install  build/output/paho_c_version /usr/local/bin</span><br><span class="line">install  build/output/samples/paho_c_pub /usr/local/bin</span><br><span class="line">install  build/output/samples/paho_c_sub /usr/local/bin</span><br><span class="line">install  build/output/samples/paho_cs_pub /usr/local/bin</span><br><span class="line">install  build/output/samples/paho_cs_sub /usr/local/bin</span><br><span class="line">/sbin/ldconfig /usr/local/lib</span><br><span class="line">ln -s libpaho-mqtt3c.so.1 /usr/local/lib/libpaho-mqtt3c.so</span><br><span class="line">ln -s libpaho-mqtt3cs.so.1 /usr/local/lib/libpaho-mqtt3cs.so</span><br><span class="line">ln -s libpaho-mqtt3a.so.1 /usr/local/lib/libpaho-mqtt3a.so</span><br><span class="line">ln -s libpaho-mqtt3as.so.1 /usr/local/lib/libpaho-mqtt3as.so</span><br><span class="line">install -m 644 src/MQTTAsync.h /usr/local/include</span><br><span class="line">install -m 644 src/MQTTClient.h /usr/local/include</span><br><span class="line">install -m 644 src/MQTTClientPersistence.h /usr/local/include</span><br><span class="line">install -m 644 src/MQTTProperties.h /usr/local/include</span><br><span class="line">install -m 644 src/MQTTReasonCodes.h /usr/local/include</span><br><span class="line">install -m 644 src/MQTTSubscribeOpts.h /usr/local/include       </span><br><span class="line">install -m 644 doc/man/man1/paho_c_pub.1 /usr/local/share/man/man1</span><br><span class="line">install -m 644 doc/man/man1/paho_c_sub.1 /usr/local/share/man/man1</span><br><span class="line">install -m 644 doc/man/man1/paho_cs_pub.1 /usr/local/share/man/man1</span><br><span class="line">install -m 644 doc/man/man1/paho_cs_sub.1 /usr/local/share/man/man1</span><br><span class="line">install -m 644 build/output/doc/MQTTClient/man/man3/MQTTClient.h.3 /usr/local/share/man/man3</span><br><span class="line">install -m 644 build/output/doc/MQTTAsync/man/man3/MQTTAsync.h.3 /usr/local/share/man/man3</span><br></pre></td></tr></table></figure></li></ol><h2 id="编写-MQTT-客户端代码"><a href="#编写-MQTT-客户端代码" class="headerlink" title="编写 MQTT 客户端代码"></a>编写 MQTT 客户端代码</h2><ol><li>客户端代码。流程就是，根据服务器地址，用户名、密码、客户端ID登录到服务器，进行主题的订阅或者向某个主题进行消息的发布这样子。从网上抄了代码(只有ctrl+c ctrl+v才能够勉强维持生活这样子)，魔改了一下贴上。这个程序在运行之后会创建一个发送线程<code>TestSend</code>，每隔 3s 发送一次信息,发送成功会通过回调函数<code>MQTTClient_deliveryToken</code>进行打印报告。收到信息会通过回调函数<code>MsgArrived_CallBack</code>进行信息的打印。  </li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MQTTClient.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*类型兼容***********************************************/</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">long</span>      <span class="keyword">uint64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">int</span>       <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">short</span>     <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">char</span>      <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">long</span>      u64;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">int</span>       u32;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">short</span>     u16;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">unsigned</span> <span class="keyword">char</span>      u8;</span><br><span class="line"><span class="comment">/***********************************************类型兼容*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 2 <span class="comment">//线程个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS         <span class="meta-string">"tcp://*.*.*.*:1883"</span> <span class="comment">//云主机作为mqtt服务器地址</span></span></span><br><span class="line"><span class="comment">//#define ADDRESS         "tcp://localhost:1883" //树莓派作为mqtt服务器地址，直接通过内网访问。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENTID        <span class="meta-string">"test_1"</span> <span class="comment">//客户端ID</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOPIC_PUBLISH   <span class="meta-string">"Hello_1"</span>  <span class="comment">//发送的主题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOPIC_SUBSCRIBE <span class="meta-string">"Hello_2"</span>  <span class="comment">//订阅的主题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD         <span class="meta-string">"Hello! My Name is "</span>CLIENTID  <span class="comment">//发送的信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QOS             1           <span class="comment">//服务质量 &lt;&lt;0-最多发送一次 1-至少保证送达一次 2-保证只送达1次</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT         10000L      <span class="comment">//超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME        <span class="meta-string">"username"</span>    <span class="comment">//登录用户名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD        <span class="meta-string">"password"</span>    <span class="comment">//登录用户名对应密码</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> MQTTClient_deliveryToken gDeliveredToken;</span><br><span class="line"><span class="comment">/** void deliveryComplete_CallBack(void *context, MQTTClient_deliveryToken deliveryToken)</span></span><br><span class="line"><span class="comment"> * @brief MQTT发送信息成功回调函数</span></span><br><span class="line"><span class="comment"> * @note 客户端发送信息成功时将会调用该函数</span></span><br><span class="line"><span class="comment"> * @param[in] context 上下文指针</span></span><br><span class="line"><span class="comment"> * @param[in] deliveryToken 发送信息的Token值</span></span><br><span class="line"><span class="comment"> * @date 2018/08/25 17:20</span></span><br><span class="line"><span class="comment"> * @auth BeGild</span></span><br><span class="line"><span class="comment"> * @email yucang_bao@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deliveryComplete_CallBack</span><span class="params">(<span class="keyword">void</span> *context, MQTTClient_deliveryToken deliveryToken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\rMessage with token %5d Send Success\n"</span>, deliveryToken);</span><br><span class="line">    gDeliveredToken = deliveryToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** int MsgArrived_CallBack(void *context, char *topicName, int topicLen, MQTTClient_message *message)</span></span><br><span class="line"><span class="comment"> * @brief 接收到MQTT数据的回调函数</span></span><br><span class="line"><span class="comment"> * @param[in] context 上下文指针</span></span><br><span class="line"><span class="comment"> * @param[in] topicName 本次接收到信息的主题</span></span><br><span class="line"><span class="comment"> * @param[in] topicLen 本次接收到信息的主题长度</span></span><br><span class="line"><span class="comment"> * @param[in] message 本次接收到数据的存储结构体</span></span><br><span class="line"><span class="comment"> *                    数据实体存放于 message-&gt;payload</span></span><br><span class="line"><span class="comment"> *                    数据长度为 message-&gt;payloadlen</span></span><br><span class="line"><span class="comment"> * @date 2018/08/25 17:20</span></span><br><span class="line"><span class="comment"> * @auth BeGild</span></span><br><span class="line"><span class="comment"> * @email yucang_bao@126.com</span></span><br><span class="line"><span class="comment"> * return 返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">MsgArrived_CallBack</span><span class="params">(<span class="keyword">void</span> *context, <span class="keyword">char</span> *topicName, <span class="keyword">int</span> topicLen, MQTTClient_message *message)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">uint8_t</span> *payloadptr;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Recive Message\n"</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"     topic: %s\n"</span>, topicName);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"     message: \n&gt;&gt;\n"</span>);</span><br><span class="line">     payloadptr = message-&gt;payload;</span><br><span class="line">     <span class="comment">//打印接受到的数据</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;message-&gt;payloadlen; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">putchar</span>(*payloadptr++);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n&lt;&lt;\n"</span>);</span><br><span class="line">     MQTTClient_freeMessage(&amp;message);</span><br><span class="line">     MQTTClient_free(topicName);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/** void ConnectLost_CallBack(void *context, char *cause)</span></span><br><span class="line"><span class="comment"> * @brief 连接丢失回调函数</span></span><br><span class="line"><span class="comment"> * @note 可能原因:</span></span><br><span class="line"><span class="comment"> *1.被挤下线</span></span><br><span class="line"><span class="comment"> *2.网络异常</span></span><br><span class="line"><span class="comment"> * @date 2018/08/25 16:18</span></span><br><span class="line"><span class="comment"> * @auth BeGild</span></span><br><span class="line"><span class="comment"> * @email yucang_bao@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectLost_CallBack</span><span class="params">(<span class="keyword">void</span> *context, <span class="keyword">char</span> *cause)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nConnection lost "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t cause: %s\n"</span>, cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** void PublishMessage(MQTTClient client,uint8_t* TopicName, uint8_t *DataBuf,uint32_t BufLen)</span></span><br><span class="line"><span class="comment"> * @brief 推送信息</span></span><br><span class="line"><span class="comment"> * @param[in] client 发送的客户端ID</span></span><br><span class="line"><span class="comment"> * @param[in] TopicName 发送的主题</span></span><br><span class="line"><span class="comment"> * @param[in] DataBuf 发送的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param[in] BufLen 发送的数据长度</span></span><br><span class="line"><span class="comment"> * @date 2018/08/25 17:49</span></span><br><span class="line"><span class="comment"> * @auth BeGild</span></span><br><span class="line"><span class="comment"> * @email yucang_bao@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PublishMessage</span><span class="params">(MQTTClient client,<span class="keyword">uint8_t</span>* TopicName, <span class="keyword">uint8_t</span> *DataBuf,<span class="keyword">uint32_t</span> BufLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MQTTClient_message Publishmsg = MQTTClient_message_initializer;</span><br><span class="line">    <span class="comment">//声明消息token</span></span><br><span class="line">    MQTTClient_deliveryToken token;</span><br><span class="line">    Publishmsg.payload = DataBuf;</span><br><span class="line">    Publishmsg.payloadlen = BufLen;</span><br><span class="line">    Publishmsg.qos = QOS;</span><br><span class="line">    Publishmsg.retained = <span class="number">0</span>;</span><br><span class="line">    MQTTClient_publishMessage(client, TopicName, &amp;Publishmsg, &amp;token);<span class="comment">//发送数据</span></span><br><span class="line">    <span class="comment">// rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);</span></span><br><span class="line">    <span class="comment">// printf("Message with delivery token %d delivered\n", token);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** void *TestSend(void *arg)</span></span><br><span class="line"><span class="comment"> * @brief 测试发送</span></span><br><span class="line"><span class="comment"> * @param[in] arg 传入参数指针</span></span><br><span class="line"><span class="comment"> * @return 返回值</span></span><br><span class="line"><span class="comment"> * @date 2018/08/25 18:58</span></span><br><span class="line"><span class="comment"> * @auth BeGild</span></span><br><span class="line"><span class="comment"> * @email yucang_bao@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">TestSend</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> MsgBuff [] = PAYLOAD;</span><br><span class="line">  MQTTClient *client = (MQTTClient *)arg;<span class="comment">//客户端句柄</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    PublishMessage(*client,TOPIC_PUBLISH,MsgBuff,<span class="built_in">strlen</span>(MsgBuff));<span class="comment">//发送信息</span></span><br><span class="line">    usleep(<span class="number">3000000L</span>);<span class="comment">//睡眠3s</span></span><br><span class="line">  &#125;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);<span class="comment">//退出线程</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**int main(int argc, char* argv[])</span></span><br><span class="line"><span class="comment"> * @brief 主函数</span></span><br><span class="line"><span class="comment"> * @param[in] argc参数个数</span></span><br><span class="line"><span class="comment"> * @param[in] argv 参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">char</span> SubTopic[] = TOPIC_SUBSCRIBE;</span><br><span class="line">    <span class="keyword">char</span> ClientID [] = CLIENTID;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    MQTTClient client;<span class="comment">//客户端句柄</span></span><br><span class="line">    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;<span class="comment">//连接参数</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    MQTTClient_create(&amp;client, ADDRESS, ClientID,</span><br><span class="line">        MQTTCLIENT_PERSISTENCE_NONE, <span class="literal">NULL</span>);<span class="comment">//根据服务器地址客户端ID创建一个可用连接</span></span><br><span class="line">    <span class="comment">/*填写连接参数*/</span></span><br><span class="line">    conn_opts.keepAliveInterval = <span class="number">20</span>;</span><br><span class="line">    conn_opts.cleansession = <span class="number">1</span>;</span><br><span class="line">    conn_opts.username = USERNAME;</span><br><span class="line">    conn_opts.password = PASSWORD;</span><br><span class="line">    <span class="comment">/*设置回调函数*/</span></span><br><span class="line">    MQTTClient_setCallbacks(client, <span class="literal">NULL</span>,</span><br><span class="line">                                    ConnectLost_CallBack,<span class="comment">/*连接丢失*/</span></span><br><span class="line">                                    MsgArrived_CallBack,<span class="comment">/*收到信息*/</span></span><br><span class="line">                                    deliveryComplete_CallBack);<span class="comment">/*信息成功发出*/</span></span><br><span class="line">    <span class="comment">/*尝试连接服务器*/</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to connect, return code %d\n"</span>, rc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//连接失败退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-------------------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Connect to EMQTT server complete"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------------------------------]\n\n"</span>);</span><br><span class="line">    <span class="comment">//订阅主题</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client [%s] ---- using QoS[%d] ---- Subscribing to topic [%s]\n\n"</span>, ClientID,QOS,SubTopic);</span><br><span class="line">    MQTTClient_subscribe(client, SubTopic, QOS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建测试发送线程</span></span><br><span class="line">    pthread_create(&amp;threads[<span class="number">0</span>], <span class="literal">NULL</span>, TestSend,&amp;client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*主循环loop*/</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Press Q&lt;Enter&gt; to quit\n\n"</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      ch = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span>(ch!=<span class="string">'Q'</span> &amp;&amp; ch != <span class="string">'q'</span>);</span><br><span class="line">    pthread_exit(&amp;threads[<span class="number">0</span>]);</span><br><span class="line">    MQTTClient_unsubscribe(client, SubTopic);<span class="comment">//取消订阅</span></span><br><span class="line">    MQTTClient_disconnect(client, <span class="number">10000</span>);<span class="comment">//断开连接</span></span><br><span class="line">    MQTTClient_destroy(&amp;client);<span class="comment">//销毁当前clien</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//退出主线程main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   点击上述代码段右上角拷贝保存为<code>mqtttest_1.c</code>，执行一面这条语句编译生成可执行文件<code>mqtttest_1</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mqtttest_1 mqtttest_1.c -lpaho-mqtt3c -lpthread</span><br></pre></td></tr></table></figure></p><h2 id="MQTT-客户端通信测试"><a href="#MQTT-客户端通信测试" class="headerlink" title="MQTT 客户端通信测试"></a>MQTT 客户端通信测试</h2><p>MQTT 的测试的话就是看两个客户端之间是否可以互相通信嘛。这里采用的方式是树莓派运行上面的客户端程序作为客户端1，用一个测试工具作为客户端2。客户端1订阅 <code>Hello_2</code> 主题 向 <code>Hello_1</code> 主题发送消息，客户端2订阅主题 <code>Hello_1</code> 向主题 <code>Hello_2</code> 发送消息。  </p><ol><li><p>执行<code>./mqtttest_1</code>运行树莓上的客户端1，成功运行会打印大致如下的信息。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi@BeGild_Raspi:~/Documents/MQtt/mqtttest $ ./mqtttest_1</span><br><span class="line">[------------------------------- Connect to EMQTT server complete--------------------------------]</span><br><span class="line"></span><br><span class="line">Client [test_1] ---- using QoS[1] ---- Subscribing to topic [Hello_2]</span><br><span class="line"></span><br><span class="line">Press Q&lt;Enter&gt; to quit</span><br><span class="line"></span><br><span class="line">Message with token     2 Send Success</span><br></pre></td></tr></table></figure><p>如果连接失败返回错误码-1、4 检查</p><ul><li>是否运行了 EMQTT 服务器、服务器地址是否填写正确。</li><li>服务器是否可达(ping 一下)，如果是云主机查看端口(1883)是否打开允许访问。</li><li>检查 EMQTT 服务器配置文件中是否添加了对应的<code>username</code>、<code>password</code> 以及<code>clientid</code>、<code>password</code>。  </li></ul></li><li><p>运行 Mqtt 客户端测试工具 MQTT.fx 作为客户端2。</p><ul><li>点击<a href="http://www.jensd.de/apps/mqttfx/" target="_blank" rel="noopener">http://www.jensd.de/apps/mqttfx/</a>下载你想要的版本。</li><li>点击安装程序。</li><li><p>一个紫色的清秀小图标，打开 MQTT.fx 稍等片刻。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-EMQTT-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/MQTT.fx.png" alt=""></p></li><li><p>点击主界面小齿轮按钮进行相关服务器登录配置。如果是树莓派作为MQTT服务器的话这里的服务器地址就替换为在花生壳里添加映射的壳域名和分配的端口号(不是1883)。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-EMQTT-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/MQTT.fx%E9%85%8D%E7%BD%AE.png" alt=""></p></li><li>点击小齿轮左边的连接列表，选择刚创建的连接。</li><li>点击小齿轮右边的连接按钮进行连接服务器。连接成功后，下面的订阅和发布功能就都可以用了。</li></ul></li><li>功能测试<ul><li>MQTT.fx 点击切换到订阅(Subscribe)界面，在输入框输入需要订阅的主题，因为这里是作为客户端2当然是订阅<code>Hello_1</code>。订阅完成之后应该就可以在右下角的界面看到收到了客户端1每隔3s发过来的 <code>Hello! My Name is test_1</code> 。</li><li>MQTT.fx 切换到发布(Pubilsh)界面，在输入框输入需要推送消息的主题。因为树莓派运行客户端1订阅的是主题<code>Hello_2</code>所以这里输入<code>Hello_2</code>。在右侧选择消息通信的质量 Qos1 (保证至少一次送达),在下方输入框任意敲入字符。点击 Pubilsh 按钮进行发布。可以在树莓派端看到其接收到了来自<code>Hello_2</code>的消息。</li><li>都能收发就测试成功了。</li></ul></li></ol><p>这里需要注意一下，如果订阅的主题就是发送的主题的话，自己也会收到自己发送的消息的。每个订阅了同一主题的客户端都能收到发布者的消息。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我发现记录过程可比实现还难，这我都断断续续写了一个星期了，记录了MQTT服务器的搭建、插件启动、配置文件修改、MQTT 客户端在树莓派上的安装和使用、两个客户端之间的通信。这一系列工作完成基本的远程通信功能就通了。<br>后续再增加手机端 MQTT 客户端的开发(本来是打算用安卓 APP 的，后来想我做的 APP 界面惨不忍睹，已申请微信小程序明日开发)、通信协议制定、MCU 端的开发和硬件的制作，然后就可以远程控制了。我可真是个小机灵鬼。    </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树莓派之-MQTT-搭建&quot;&gt;&lt;a href=&quot;#树莓派之-MQTT-搭建&quot; class=&quot;headerlink&quot; title=&quot;树莓派之 MQTT 搭建&quot;&gt;&lt;/a&gt;树莓派之 MQTT 搭建&lt;/h2&gt;&lt;p&gt;每天出门总怀疑自己灯没关、空调没关，晚上睡觉的时候躺下才意识到灯没关、然而开关却理我特别远，这我可接受不了 2333 ，所以产生了这种刚需🤣，这里记录一下搭建&lt;a href=&quot;https://baike.baidu.com/item/MQTT/3618851&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MQTT&lt;/a&gt;环境的过程。&lt;br&gt;
    
    </summary>
    
      <category term="树莓派" scheme="http://begild.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="MQTT" scheme="http://begild.top/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装系统和配置</title>
    <link href="http://begild.top/article/fd8be0b3.html"/>
    <id>http://begild.top/article/fd8be0b3.html</id>
    <published>2018-08-19T05:12:23.000Z</published>
    <updated>2018-12-04T15:20:39.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近打算玩一玩树莓派，感觉从毕业之后荒了蛮久没有新的东西注入了。其实有在考虑要不要记录这个安装的过程，因为其实教程已经漫天飞了，有重复造轮子之嫌。不过听说好记性不如烂笔头，记一下方便回顾也很有成就感不是吗？顺便说一下我的机器：树莓派3B+，因为穷，只买了裸板嘤嘤嘤。<a id="more"></a></p><h2 id="下载树莓派系统"><a href="#下载树莓派系统" class="headerlink" title="下载树莓派系统"></a>下载树莓派系统</h2><ol><li>从官网的下载页面<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/</a>可以看到树莓派支持的系统有好多种，这里下载官方的 RASPBIAN 系统，这个是基于 Debian 进行开发的。当然你也可以尝试一下 Ubuntu MATE 也蛮不错的。</li><li>点击大大的 PASPBIAN 图标可以进入选择下载 PASPBIAN DESKTOP 版还是 Mini 版。这里选择DESKTOP吧，安装好之后可以选择关闭视频输出用 VNC 远程桌面的。</li><li>点击 RASPBIAN STRETCH WITH DESKTOP 板块的<a href="https://downloads.raspberrypi.org/raspbian_latest" target="_blank" rel="noopener">Download Zip</a> 按钮即可开始下载。点击-&gt;<a href="https://downloads.raspberrypi.org/raspbian_latest" target="_blank" rel="noopener">这里</a>可以下载最新的桌面版 PASPIAN 系统。</li><li>下载完成之后就可以开始下一步了，不用解压，就保持为 zip 格式。<h2 id="安装烧录镜像的工具-Etcher"><a href="#安装烧录镜像的工具-Etcher" class="headerlink" title="安装烧录镜像的工具 Etcher"></a>安装烧录镜像的工具 Etcher</h2>这个工具是linux macOS Windows都可以支持的，比起 Win32DiskImager来，长的还不错，界面也很简单(超级简单)。</li><li>去官网<a href="https://etcher.io/" target="_blank" rel="noopener">https://etcher.io/</a> 下载最新版本。</li><li>下载完毕之后安装，安装完毕打开就可以使用了。<h2 id="烧写系统镜像"><a href="#烧写系统镜像" class="headerlink" title="烧写系统镜像"></a>烧写系统镜像</h2></li><li>选择你下载的系统镜像文件(.zip)</li><li>选择你写的SD卡所在的盘符。</li><li>点击 Flash，等待进度的完成。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/etcher%E4%BD%BF%E7%94%A8.gif" alt="etcher使用"></li></ol><p>烧录完毕之后，SD卡会被分区为两个盘符，一个名字叫 boot(启动分区) 另一个叫 rootfs(根文件系统)。boot分区只有几十M，除去 rootfs 之外剩下的SD卡空间都是未被分配的状态所以 rootfs 只比系统大一点，等启动树莓派之后在树莓派的配置项里选择 SD 卡扩容把整个 SD 卡剩余空间合并到 rootfs 里。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/%E7%A9%BA%E9%97%B4%E6%9C%AA%E5%88%86%E9%85%8D.png" alt=""></p><h2 id="系统视频输出的配置"><a href="#系统视频输出的配置" class="headerlink" title="系统视频输出的配置"></a>系统视频输出的配置</h2><p>这个配置是用于正确输出视频信号给显示器显示，树莓派会自动检测显示器属性自动调整的，当你的显示效果没有达到预期(HDMI-&gt;VGA)时可以通过手动配置一下。<br>配置项在  <font color="#00ffff" size="4">/boot/config.txt</font>文件里。打开该配置文件进行修改即可。<br>关于配置的介绍可以在<a href="http://rpf.io/configtxt" target="_blank" rel="noopener">这里</a>看到。这里的配置需要贴合你显示器的属性，设置的教程可以参照-&gt;<a href="http://shumeipai.nxez.com/2013/08/31/custom-display-resolution-raspberry-pie.html" target="_blank" rel="noopener">自定义树莓派的显示分辨率</a> 进行显示器分辨率<code>hdmi_mode</code>的调整。我的显示器是2K屏，计算机显示器，配置项如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># uncomment if you get no picture on HDMI for a default &quot;safe&quot; mode</span><br><span class="line">hdmi_safe=1</span><br><span class="line"># uncomment this if your display has a black border of unused pixels visible</span><br><span class="line"># and your display can output without overscan</span><br><span class="line">disable_overscan=1</span><br><span class="line"># uncomment if hdmi display is not detected and composite is being output</span><br><span class="line">hdmi_force_hotplug=1</span><br><span class="line"># uncomment to force a specific HDMI mode (this will force VGA)</span><br><span class="line">hdmi_group=2</span><br><span class="line">hdmi_mode=76</span><br><span class="line">hdmi_ignore_edid=0xa5000080</span><br><span class="line"># uncomment to force a HDMI mode rather than DVI. This can make audio work in</span><br><span class="line"># DMT (computer monitor) modes</span><br><span class="line">hdmi_drive=2</span><br><span class="line"># uncomment to increase signal to HDMI, if you have interference, blanking, or</span><br><span class="line"># no display</span><br><span class="line">config_hdmi_boost=4</span><br></pre></td></tr></table></figure></p><p>配置完毕，插上SD卡、hdmi线、电源即可看到树莓派启动，如果使用的是HDMI转VGA为了保证视频的稳定这里最好使用单独电源供电的转换头。开机显示如下：<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA.jpg" alt=""></p><h2 id="系统选项配置"><a href="#系统选项配置" class="headerlink" title="系统选项配置"></a>系统选项配置</h2><p>插上鼠标键盘,启动系统之后打开终端，输入<code>sudo raspi-config</code>命令即可进行配置，界面如下。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/raspi-config.jpg" alt=""><br>配置界面的详细说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1. 修改登录密码。</span><br><span class="line">2. 网络选项：</span><br><span class="line">    1. 树莓派在网络上的名字(在路由器管理界面可以看到)</span><br><span class="line">    2. WIFI名称和密码</span><br><span class="line">    3. 网络是否可以被探测。</span><br><span class="line">3. 启动选项：</span><br><span class="line">    1. 启动选择桌面还是控制台，控制台就没有界面黑乎乎的。</span><br><span class="line">       1. 控制台不自动登录</span><br><span class="line">       2. 控制台自动登录</span><br><span class="line">       3. 桌面环境不自动登录</span><br><span class="line">       4. 桌面环境自动登录</span><br><span class="line">    2. 是否在启动是等待网络连接完成。</span><br><span class="line">    3. 是否启用画面过渡。用画面过渡开机过程，还是使用文本过渡(开机的时候刷刷刷的文本启动信息)。</span><br><span class="line">4. 本地化选项：</span><br><span class="line">    1. 选择语言。在弹出的列表里上下移动直至找到 zh_CN.UTF-8 UTF-8。空格进行选择，回车进行确认。</span><br><span class="line">    2. 选择时区。Etc</span><br><span class="line">    3. 选择键盘布局。国际标准105键。</span><br><span class="line">    4. 选择WIFI地区。CN-China</span><br><span class="line">5. 接口选项：这里主要是树莓派对外的接口功能使能。</span><br><span class="line">    1. 摄像头。选择是否使用摄像头。根据需要选择使能。</span><br><span class="line">    2. SSH。选择是否启用SSH进行远程连接。选择使能。</span><br><span class="line">    3. VNC.选择是否启用VNC作为远程桌面连接。根据需要选择使能。</span><br><span class="line">    4. SPI。选择是否启用SPI接口。根据需要选择使能。</span><br><span class="line">    5. IIC。选择是否启用IIC接口。根据需要选择使能。</span><br><span class="line">    6. 串口Serial。选择是否启用串口。根据需要选择使能。</span><br><span class="line">    7. 1-Wire。选择是否启用单线接口。根据需要选择使能。</span><br><span class="line">    8. Remote GPIO。选择是否允许远程控制GPIO。根据需要选择使能。</span><br><span class="line">6. 超频选项：CPU超频。</span><br><span class="line">7. 高级选项：</span><br><span class="line">   1. 扩展SD卡文件系统，也就是在刷入树莓派系统时候会有没分配的空闲空间，通过这个选项就可以将SD卡完全整合起来。</span><br><span class="line">   2. 过扫描选项。如果显示器显示有黑边可以开启这个选项。关于过扫描可以看http://bbs.a9vg.com/thread-2358167-1-1.html。</span><br><span class="line">   3. 修改显卡可用内存大小。默认值64</span><br><span class="line">   4. 声音选项。选择声音的输出方向。</span><br><span class="line">      1. 自动。根据有效的输出源输出。</span><br><span class="line">      2. 通过3.5耳机接口输出</span><br><span class="line">      3. 通过HDMI传输音频。</span><br><span class="line">   5. 分辨率选项。选择特定的分辨率作为输出视频的分辨率。根据显示器配置进行选择。</span><br><span class="line">   6. 像素点加倍选项。选择是否将像素进行2*2映射。我选择之后画面显示不全，很模糊。不知道干嘛用的感觉像是分辨率变低了。</span><br><span class="line">   7. Open GL驱动选项。选择是否启用open GL桌面驱动程序。这个是硬件加速的选项，如果使用桌面可以选择启用该功能。这个选项我其实并没有什么感觉，没有试过。可以看下https://www.jianshu.com/p/2438d2c76cdb。</span><br><span class="line">      1. Full KMS 这个效率更高全部通过内核直接输出，但是兼容性差一些，遇到一些远程桌面软件可能会出问题。</span><br><span class="line">      2. FAKE KMS 该选项兼容性好一些。</span><br><span class="line">      3. 使用软件渲染。不使用Open GL。</span><br><span class="line">8. 升级。检查升级系统。</span><br><span class="line">9. 关于树莓派配置工具的说明。</span><br></pre></td></tr></table></figure></p><p>我用的系统2018-06-27-raspbian-stretch是可以通过桌面左上角的小树莓图标-&gt;首选项-&gt;树莓派配置进行配置的。<br>配置完毕之后选择 Finish 按钮进行重启，生效更改。<br>我的配置大致如下：<br>    修改登录密码、使用控制台自动登录、启用 SSH 和 VNC 、不超频、扩展SD卡、不进行像素点加倍、不使用Open GL(不好意思我只用SSH连接)，另外GPU内存我就按照的默认64M来，之后需要再修改吧。</p><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>虽然之后都是使用SSH进行连接，但是！！！偶尔使用桌面时依然不能忍受没有中文的情况啦。运行下面的三条命令进行安装，最后使用reboot重启系统生效更改。通过 ctrl+space 可以切换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx #安装 fctix 输入法框架</span><br><span class="line">sudo apt-get install fcitx-pinyin     # 安装fcitx拼音</span><br><span class="line">sudo apt-get install fcitx-googlepinyin  # 安装google拼音</span><br></pre></td></tr></table></figure></p><p>这样就完成了树莓派个性化的配置啦。</p><h2 id="使用SSH进行树莓派的连接"><a href="#使用SSH进行树莓派的连接" class="headerlink" title="使用SSH进行树莓派的连接"></a>使用SSH进行树莓派的连接</h2><p>这里推荐使用Finall shell这个远程连接软件。可以实时监控CPU、内存、磁盘等的使用，可以有命令历史，自动补全等。免费版本已经够使用了。</p><ol><li>Windows 点击<a href="http://www.hostbuf.com/downloads/finalshell_install.exe" target="_blank" rel="noopener">下载</a>Finall shell最新版本。官网:<a href="http://www.hostbuf.com/" target="_blank" rel="noopener">http://www.hostbuf.com/</a>。官网看起来毫无美感，胜在简单没有广告.</li><li>下载之后运行安装。安装完毕打开软件。可以看到一个右边是一些图表栏，用于显示当前系统一些信息。右边是命令行窗口，下面是远程文件管理系统可以用来传输文件。</li><li>点击右上角文件夹样式的小图标打开连接管理器，点击左上角白色文件夹加号建立一个SSH连接。<ol><li>输入连接名称(标识，方便查看比如：树莓派)。  </li><li>主机，填入树莓派的IP地址。  <ul><li>这里可以用树莓派运行 <code>ifconfig</code> 命令查看ip地址,应该是<code>192.168.1.*</code></li><li>也可以通过浏览器输入<code>192.168.1.1��?92.168.1.0</code> 进入路由器管理界面查看树莓派的IP地址。</li></ul></li><li>端口默认22.方法使用密码，用户名为 pi (树莓派默认用户名)，密码为你的登录密码。  </li><li>点击<code>确定</code>建立连接成功。</li></ol></li><li>双击新建的连接进行连接，会在主窗口的右边命令行栏新建一个连接分页，连接成功就能看到大致如下的界面。<br><img src="http://begild-one.top/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/SSH%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.png" alt=""></li><li>软件的其他个性化配置自行摸索，大致有命令行主题，颜色等的配置吧。点击软件右上角的三条横线图标-&gt;选项可以找到。<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>这样就完成树莓派的基本配置和使用了，利用 SSH 整个树莓派只需要连接一根USB电源线就可以愉快的玩耍了，当然这里的电源适配器一定要稳定电流足量(2A以上)，不要拿那种10块钱包邮的电源适配器。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近打算玩一玩树莓派，感觉从毕业之后荒了蛮久没有新的东西注入了。其实有在考虑要不要记录这个安装的过程，因为其实教程已经漫天飞了，有重复造轮子之嫌。不过听说好记性不如烂笔头，记一下方便回顾也很有成就感不是吗？顺便说一下我的机器：树莓派3B+，因为穷，只买了裸板嘤嘤嘤。
    
    </summary>
    
      <category term="树莓派" scheme="http://begild.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派安装系统" scheme="http://begild.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一种分层、高扩展性通信协议的总结</title>
    <link href="http://begild.top/article/cc12b1fd.html"/>
    <id>http://begild.top/article/cc12b1fd.html</id>
    <published>2018-07-22T01:59:34.000Z</published>
    <updated>2018-12-04T15:38:16.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="渊源"><a href="#渊源" class="headerlink" title="渊源"></a>渊源</h2><p>大概因为自己专业是通信工程，所以一直以来对通信都还是很有兴趣的，通信协议的作用就是让通信的双方明确知道通信实体的意义。通信协议的范畴太大了，从最底层的硬件之间接口的协议到最上层的应用层的协议无一不是为了传输数据所做的工作 <a id="more"></a></p><h2 id="硬件的接口协议"><a href="#硬件的接口协议" class="headerlink" title="硬件的接口协议"></a>硬件的接口协议</h2><ul><li>硬件的接口协议主要是为了正确的传输数据的逻辑0和1，在不同的物理实体接口中通过不同的电平标准，不同的时序，不同的物理线数来完成整个工作。平时接触到最多的IIC、SPI、UART、USB他们都有着自己一套物理层的通信接口不过线数和时序比较简单，除此之外，SATA接口，RJ45网口，HDMI接口等也有自己的一套物理层的接口协议他们的接口线数和时序通常都比较复杂。如果你不按照物理层的接口协议来传输数据那么对方连获取正确数据的能力都不具备。  </li><li>当两种不同的接口间相互兼容时就需要转换器，这个转换器其实就是具备两种硬件接口协议的设备，将一种接口的数据正确接收回来转化为另外一种接口可以识别的物理电平数据然后通过时序和接口线发送出去。当然有些时候是需要进行取舍或填补的，像VGA和HDMI，他们都属于传输视频的接口，但是VGA并不具备传输音频的能力所以HDMI转VGA必然会丢失音频的数据，同时因为VGA传输的是模拟的数据当转为HDMI时必然会丢失细节数据。</li><li>硬件的接口协议类比于声带和耳朵，声带发声，耳朵收听声音。声音可通过空气传播，空气就是物理线，声带和耳朵就是一套收发的物理设备，他们之间的通信通过声带震动空气发射，耳朵通过耳膜接收震动进行获取。</li></ul><h2 id="上层的通信协议"><a href="#上层的通信协议" class="headerlink" title="上层的通信协议"></a>上层的通信协议</h2><ul><li>完成了硬件的接口协议就能正确的传输你想要发送的数据了对方也能正确的接收到你的数据，相当于你拥有一个完好的耳朵，能接收到各种符合人耳能听到的声音了(超声波次声波听不到).</li><li>此时你还是语言不通！因为在你眼里都是声音但是你无法知道对面所说的是什么意思，这时候你就需要一个学习的过程，学习对方的语言。这个语言其实就是规定了各种发音的组合构成的意义也就是”通信协议”,我们只有知道每个发音以及构成的意义才能正确了解对方所说的含义.</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>促使本文产生的源头就是入职这段时间里负责的一个测试工具的开发中所用到的通信协议，因为之前自己也做过一些通信协议不过感觉看了项目组里大佬给的这个协议以及思想感觉很受用，所以在这里记录一下。这里说的是(串口)UART为通信硬件载体进行说明.</p><h2 id="自己做过的一些协议"><a href="#自己做过的一些协议" class="headerlink" title="自己做过的一些协议"></a>自己做过的一些协议</h2><ul><li>之前自己在本科期间做过的一些项目也需要根据传输的东西制定一些通信协议，不过都比较简单考虑的点也没有那么多，有基于16进制传输的也有基于字符串传输的16进制传输的基本就是为了机器更好识别，解析效率也会高很多。字符串为载体的传输就是为了更好的观察，更加容易分析16进制的传输比如SDH，网络音视频流等；字符串传输比如JSON，HTTP包。</li><li>一个简16进制传输的控制协议，16进制传输，通过解析头尾提取出帧，但是没有差错校验。这可以当成一个数组然后分析每一部分就可以进行解析了，因为实现的功能比较简单所以也用不着很复杂。这种方式在不易调试但是数据量小并且解析较快。</li></ul><table><thead><tr><th style="text-align:center">帧头</th><th style="text-align:center">受控设备类型</th><th style="text-align:center">受控设备编号</th><th style="text-align:center">网关设备识别号</th><th style="text-align:center">命令/数据</th><th style="text-align:center">帧尾</th></tr></thead><tbody><tr><td style="text-align:center">0XAA</td><td style="text-align:center">设备属性</td><td style="text-align:center">网关分配</td><td style="text-align:center">网关</td><td style="text-align:center">控制和交互</td><td style="text-align:center">0X55</td></tr><tr><td style="text-align:center">8bit</td><td style="text-align:center">8bit</td><td style="text-align:center">8bit</td><td style="text-align:center">16bit</td><td style="text-align:center">8bit</td><td style="text-align:center">8bit</td></tr></tbody></table><ul><li>一个简单的字符串传输的控制协议示例,用于控制指示灯的状态，诸如充电，语音交互等模式。采用JSON为载体，方便调试和查看，但是解析效率较16进制传输低。<br><img src="http://begild-one.top/%E4%B8%80%E7%A7%8D%E5%88%86%E5%B1%82%E9%AB%98%E6%89%A9%E5%B1%95%E6%80%A7%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%BB%E7%BB%93/JSON%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BE%8B.png" alt="JSON载体通信协议实例"><ul><li>其实自己做的时候也有考虑过兼容和扩展的问题，不过其实都没有很好的解决办法，因为最好的就是变长的数据传输可以任意扩展数据的大小和数据形式，但是依然没有能解决后续扩展协议和前期协议之间的潜在冲突。但是接下来的这个协议组织方式很好的解决了这个麻烦。读完下面这个协议你就会觉得之前我做的，多捞哦。</li></ul></li></ul><h2 id="分层、高扩展协议"><a href="#分层、高扩展协议" class="headerlink" title="分层、高扩展协议"></a>分层、高扩展协议</h2><ul><li><font color="#FF0FFF" size="4">分层</font>：分层的思想类比于计算机网络分层，不同的层次负责不同的功能。不过这里没有那么复杂只是思想上一致，那就是将以协议帧分为不同的层次，便于数据的控制和分析。所有的数据都按1字节对齐 。</li></ul><ol><li><p>顶级：控制传输层，基本包括，帧识别头、帧校验(CRC)、命令码、操作码、数据段长度、数据段载体。根据需要可以增加目的地址，源地址，返回码，消息码等用作透传和反馈的字段。其展现结构示例为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  type Head;     <span class="comment">//帧识别头，用于标识帧的开始</span></span><br><span class="line">  type CRC;      <span class="comment">//CRC校验，用于验证帧的完整性</span></span><br><span class="line">  type Cmd;      <span class="comment">//命令码，用于标识帧的类型或者帧的作用</span></span><br><span class="line"><span class="comment">//  type MsgID;    //消息码，用于标识本通信协议帧的识别码。</span></span><br><span class="line">  type Operat;   <span class="comment">//操作码，用于标识帧的一些使用操作，比如是否是需要接收方进行响应。</span></span><br><span class="line"><span class="comment">//  type SrcAddr;  //源地址，用于存储发送方的识别号，因为可能存在多个设备进行数据交互。</span></span><br><span class="line"><span class="comment">//  type DstAddr;  //目的地址，用于存储接收方的识别号，因为可能需要中间设备进行透传。</span></span><br><span class="line"><span class="comment">//  type Ret;      //返回码，用于反馈接收方的处理结果是否成功或者错误码。</span></span><br><span class="line">  type Reserve;   <span class="comment">//预留</span></span><br><span class="line">  type Datalen;  <span class="comment">//数据段的长度，用于进行数据段的准确读取。</span></span><br><span class="line">  type Data[<span class="number">1</span>];  <span class="comment">//数据段的载体，这里只标识数据段的第一个字节使其内存连续，可连续读取数据。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>二级：用于统计三级数据子包的个数，因为每个帧可能包含若干个数据包，所以需要一个统计本次数据包的总数，便于数据包的分包。这里是不需要增加数据长度字段的因为每个数据包的长度是不一定的，其展现结构示例为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  type CellCnt;  <span class="comment">//数据细胞单元数量，用于统计三级数据细胞单元的个数</span></span><br><span class="line">  type Data[<span class="number">1</span>];  <span class="comment">//数据段的载体，这里只标识数据段的第一个字节使其内存连续，可连续读取数据。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>三级：在该层级用于存储每个数据细胞单元的实体，包括一个数据包意义字段，一个数据长度字段，一个数据载体字段构成。这里是必须要使用数据长度字段的，因为每个数据包的长度是不定长的但是在内存里是连续的，如果没有该字段将无法进行下一个数据包的准确读取。其展现结构示例为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  type CellCmd;  <span class="comment">//数据细胞单元的意义或命令，用于识别该数据包的具体意义，做相应具体的操作和处理。</span></span><br><span class="line">  type Datalen;  <span class="comment">//数据段的长度，用于进行数据段的准确读取。</span></span><br><span class="line">  type Data[<span class="number">1</span>];  <span class="comment">//数据段的载体，这里只标识数据段的第一个字节使其内存连续，可连续读取数据。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ol><ul><li><font color="#FF0FFF" size="4"> 高扩展性 </font>：因为分层之后每一个级别都有不同的作用，顶层和二层是不会变的,但是三层的数据结构是可以自由扩展并且不影响之前的已有的功能，可以根据需要增加四级五级等等，但是对于上层来说都是三级数据包都去按照 <code>CellCmd</code> 去识别是否是自己已有的，能处理的包，不能处理就丢弃，不会影响现有的功能。</li></ul><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>一开始读取这个协议的是否觉得晦涩难懂，明明就那么点功能还要大费周折，又是封装又是又是分层，解析的难度大大加大，直接用数组下标宏去解析不就OK了。<br>后来搞通了，不得不说真的太有用了，无论你是多复杂的数据结构，按照这个来组包兼容性极强，并且代码阅读更加清晰。其传输采用16进制传输，找到帧头，强制类型转化为结构体指针，然后一层一层的剖析下去，扩展的数据包解析，就依次按照剥洋葱的方式层层递减。<br>当然上面的这个只是一种思想，至于所有的数据的分层结构，体系都可以千变万化，比如二级的数据包个数就可以归在顶级里面从而取消二级结构。<br>感谢安维大佬以及盛培大哥的代码、文档</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;渊源&quot;&gt;&lt;a href=&quot;#渊源&quot; class=&quot;headerlink&quot; title=&quot;渊源&quot;&gt;&lt;/a&gt;渊源&lt;/h2&gt;&lt;p&gt;大概因为自己专业是通信工程，所以一直以来对通信都还是很有兴趣的，通信协议的作用就是让通信的双方明确知道通信实体的意义。通信协议的范畴太大了，从最底层的硬件之间接口的协议到最上层的应用层的协议无一不是为了传输数据所做的工作
    
    </summary>
    
      <category term="通信协议" scheme="http://begild.top/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="串口(UART)" scheme="http://begild.top/tags/%E4%B8%B2%E5%8F%A3-UART/"/>
    
      <category term="分层、高扩展通信协议" scheme="http://begild.top/tags/%E5%88%86%E5%B1%82%E3%80%81%E9%AB%98%E6%89%A9%E5%B1%95%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>多系统GRUB引导丢失修复</title>
    <link href="http://begild.top/article/6d520ba7.html"/>
    <id>http://begild.top/article/6d520ba7.html</id>
    <published>2018-05-10T04:27:11.000Z</published>
    <updated>2018-05-10T13:52:45.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言-垃圾话"><a href="#前言-垃圾话" class="headerlink" title="前言(垃圾话)"></a>前言(垃圾话)</h2><p>这段话忽略不影响教程。本文主要记录一下我粗心大意之下造成的大出血事件。前几天做了一个给电脑供电的移动电源(？？？)听起来很奇怪但是这个需求确实发生了。emmmm 可能是我和电源有着不可理解的对立关系(成功在实验室造成了两次电池事故😪)，因为要实际测试”充电宝”的续航和充电情况，所以我成功的献祭了我的电脑，我自认为已经检查了线路，接口，电压，保证电流不超过限额，但是我万万没有想到，极性搞错了。我TM🙃…把正负极搞反了接上去瞬间黑屏(完全不慌.jpg)，所幸的是只是烧了笔记本的电源管理芯片，没有伤及无辜。送去电脑店，没有这种芯片，上淘宝买芯片发顺丰修修修，一来一去就是3天，期间只能勉强靠树莓派过过日子。但是修好了之后出现了新的问题，开不了机进不去系统，然后经过3个多小时的搜查改，终于修好了，所以在这里记录一下。<a id="more"></a></p><h2 id="问题的具体描述"><a href="#问题的具体描述" class="headerlink" title="问题的具体描述"></a>问题的具体描述</h2><p>这个问题的表现就是，开机自检能通过，但是出现不了引导界面反而出现的是一个叫做 grub rescue的界面，我这里因为修的时候并没有拍照，所以只能用文字大概描述一下。</p><ul><li>开机之后通过自检，然后检测引导什么的，但是他提示 <code>erro:file&#39;/boot/grub/i386-pc/normal.mod&#39; not found</code> 这个错误。</li><li>接下来就是如下的一个命令行界面，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub rescue&gt;&gt;______________</span><br></pre></td></tr></table></figure></li></ul><h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>这个问题本质上就是找不到引导的文件，迷路了找不到任何导航的东西。但是有两种不同的情况(据我搜索的结果)。</p><ol><li>grub 文件还在系统里，但是引导至该文件的设置出错，也就是这个文件的路径不见了。</li><li>grub 的文件已经丢失了，也就是硬盘里不存在这个文件了。</li></ol><h2 id="验证是哪种情况"><a href="#验证是哪种情况" class="headerlink" title="验证是哪种情况"></a>验证是哪种情况</h2><p>下面几步即可完成。</p><ol><li><code>grub rescue&gt;&gt;</code> 输入 <code>ls</code> 。可以看到输出了很多 hd*，msdos* 之类的东西，hd* 就是第几块存储设备，msdos*也就是分区。 </li><li>通过  <code>ls (hd*,msdos*)/boot/grub</code> 可以查看是不是grub所在的分区以及文件是否存在。比如我查看 hd0，msdos5 那么命令就是 <code>ls (hd0,msdos5)/boot/grub</code>，这里我在网上看到有些直接输入<code>ls (hd0,msdos5)/grub</code> (grub摆放的位置不一样)。<ul><li>如果结果显示 <code>error:unknown filesystem</code> 代表并不是 grub 所在的分区。</li><li>如果结果里有<code>i386-pc</code> 文件夹，那么代表你的是第一种情况。</li><li>如果结果里没有错误提示但是也没有显示<code>i386-pc</code> 文件夹，那么你的情况就是第二种（我的恰好也就是第二种）。</li></ul></li></ol><h2 id="设置-grub-路径"><a href="#设置-grub-路径" class="headerlink" title="设置 grub 路径"></a>设置 grub 路径</h2><p>我不知道第二种情况需不需要这样设置，经过我的后来思考觉得应该不需要的，但是还是建议设置一下防止出问题。</p><ol><li>在<code>grub rescue&gt;&gt;</code> 输入 <code>set root=(hd*,msdos*)</code> 设置根目录。</li><li>在<code>grub rescue&gt;&gt;</code> 输入 <code>set prefix=(hd*,msdos*)/boot/grub</code> 设置 grub 目录。</li><li>通过在<code>grub rescue&gt;&gt;</code> 输入 <code>set</code>可以看到设置的结果。 </li></ol><h2 id="第一种情况解决办法"><a href="#第一种情况解决办法" class="headerlink" title="第一种情况解决办法"></a>第一种情况解决办法</h2><p>下面的步骤是网上搬过来的，因为我不是这个情况，原文见<a href="https://blog.csdn.net/peerless1994/article/details/52226169" target="_blank" rel="noopener">博客</a></p><ol><li>输入 <code>insmod normal</code> 回车</li><li>输入 <code>normal</code>回车 就能进入 grub 引导菜单界面。</li><li>如果你能选择 linux 并启动那么跳到第5步否则第4步。</li><li><p>在 grub 界面按下键盘 <code>C</code> 进入命令行模式输入如下命令。* 就是你刚找到的正确的引导分区的相关序号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set root=(hd*,msdos*)</span><br><span class="line">Set prefix=(hd*,msdos*)</span><br></pre></td></tr></table></figure></li><li><p>启动 linux 在终端输入如下命令，(其实我更推荐使用 boot-repair 更傻瓜，更安全~ ~)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install /dev/sda (通过 ls /dev/sd* 查看磁盘情况)</span><br></pre></td></tr></table></figure></li></ol><h2 id="第二种情况解决办法"><a href="#第二种情况解决办法" class="headerlink" title="第二种情况解决办法"></a>第二种情况解决办法</h2><p>对于二种情况稍显复杂。需要通过一个 liveCD 来拯救。</p><ol><li>需要<br> 硬件：一个可以用的电脑、一个U盘(会格式化注意备份)；<br> 软件：一个 Ubuntu 系统镜像、UltraISO软碟通(亲测U深度一键装机没用)。 </li><li>打开软碟通菜单栏–&gt;文件–&gt;打开下载来的iso镜像。 </li><li>软碟通菜单栏–&gt;启动–&gt;写入硬盘镜像，在弹出的选项里选择U盘然后点击格式化，格式化完成之后点击写入。等待写入完成。 </li><li>插入U盘，进入你电脑的 bios ,我的是在按下电源键启动之后狂按 F2 这里你需要上网搜一下你电脑对应的按键是啥，进去时候找到 boot 设置将U盘列为第一启动项(这里因电脑而异希望你有点灵性)，这里不懂的话上网搜一下怎么开机进入U启动盘。 </li><li>顺利的话就进入了一个 linux 的安装界面。在右边的语言列表里滑到最下面选择中文。然后在右边的两个大图标选项里选择试用 Ubuntu ，这样就进入了一个看起来和正常安装没有区别的 Ubuntu 系统。 </li><li><p><code>Ctrl+alt+T</code> 呼出终端，输入以下命令安装 boot-repair 并启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair //添加 boot-repair 软件源</span><br><span class="line">sudo apt-get update  //更新软件列表 </span><br><span class="line">sudo apt-get install -y boot-repair  //安装 boot-repair</span><br><span class="line">boot-repair //启动 boot-repair</span><br></pre></td></tr></table></figure></li><li><p>按照提示傻瓜式的操作即可完成修复，耐心等待。</p><ul><li>在过程中如果提示某个硬盘是否是可拆卸的选择否，如果是移动硬盘就选择是。</li><li>修复完成会问你是否选择生成报告，点击是，生成报告然后给你一个网址，复制网址到浏览器即可访问结果，可以看到你的分区和引导以及引导的系统。</li></ul></li><li>关闭计算机，拔掉U盘，重启计算机即可进入引导~ ~。windows 和 linux 都可以进入了，美滋滋。</li><li>启动 windows 可能会提示是否要跳过系统检查，这个很快的，也就20几秒就好了。</li></ol><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><ol><li>我这里出现一个情况，我原本的默认引导是用那种黑白屏的引导，然后如果点击 Ubuntu 会跳转到 grub 引导但是经过这个操作之后，grub变成了默认的引导点击windows之后会跳到黑白屏的引导。<br>解决办法：下载EasyBCD编辑引导菜单删除 Ubuntu 的引导选项就OK了，就默认使用 grub 引导(之前就想这么搞来着误打误撞美滋滋)。</li><li>grub默认的不是windows启动，通过该<a href="https://jingyan.baidu.com/article/f71d60379e16021ab641d1ab.html" target="_blank" rel="noopener">教程</a> 即可调整默认的启动系统，如果链接失效搜索一下 grub 调整启动顺序~ ~。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言-垃圾话&quot;&gt;&lt;a href=&quot;#前言-垃圾话&quot; class=&quot;headerlink&quot; title=&quot;前言(垃圾话)&quot;&gt;&lt;/a&gt;前言(垃圾话)&lt;/h2&gt;&lt;p&gt;这段话忽略不影响教程。本文主要记录一下我粗心大意之下造成的大出血事件。前几天做了一个给电脑供电的移动电源(？？？)听起来很奇怪但是这个需求确实发生了。emmmm 可能是我和电源有着不可理解的对立关系(成功在实验室造成了两次电池事故😪)，因为要实际测试”充电宝”的续航和充电情况，所以我成功的献祭了我的电脑，我自认为已经检查了线路，接口，电压，保证电流不超过限额，但是我万万没有想到，极性搞错了。我TM🙃…把正负极搞反了接上去瞬间黑屏(完全不慌.jpg)，所幸的是只是烧了笔记本的电源管理芯片，没有伤及无辜。送去电脑店，没有这种芯片，上淘宝买芯片发顺丰修修修，一来一去就是3天，期间只能勉强靠树莓派过过日子。但是修好了之后出现了新的问题，开不了机进不去系统，然后经过3个多小时的搜查改，终于修好了，所以在这里记录一下。
    
    </summary>
    
      <category term="Tools" scheme="http://begild.top/categories/Tools/"/>
    
    
      <category term="grub" scheme="http://begild.top/tags/grub/"/>
    
  </entry>
  
  <entry>
    <title>Linux子系统图形界面</title>
    <link href="http://begild.top/article/858a9730.html"/>
    <id>http://begild.top/article/858a9730.html</id>
    <published>2018-04-19T12:00:01.000Z</published>
    <updated>2018-12-04T14:43:38.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搞完Windows下Linux下子系统的启用，可以用命令行进行使用但是却是一个完全没有界面的系统。这样怎么能拼过虚拟机呢对吧。所以：图形界面启动！。<a id="more"></a></p><h2 id="Windows-X-Server"><a href="#Windows-X-Server" class="headerlink" title="Windows X Server"></a>Windows X Server</h2><ol><li>下载 VcXsrv <a href="https://sourceforge.net/projects/vcxsrv/files/latest/download" target="_blank" rel="noopener">https://sourceforge.net/projects/vcxsrv/files/latest/download</a> 用迅雷下会快一些👀。</li><li>运行下载下来的 VcXsrv 安装程序，安装位置自己选，开心就好。</li><li>安装完成之后会有两个软件启动方式，选择用 XLaunch 启动，在启动界面选择 One large windows 方式，显示器编号：0，接下来一路 Next 到完成结束。然后会出现一个黑黑的界面。<br><img src="http://begild-one.top/XLunch%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE.png" alt="XLunch启动设置"></li></ol><h2 id="Ubuntu的桌面软件安装"><a href="#Ubuntu的桌面软件安装" class="headerlink" title="Ubuntu的桌面软件安装"></a>Ubuntu的桌面软件安装</h2><ol><li>安装 Ubuntu 桌面软件，unity，compiz配置软件,下载的软件很大。大概需要2.5个G的空间，耐心等待(我大概用了15分钟左右才装好)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</span><br></pre></td></tr></table></figure></li></ol><h2 id="Ubuntu的桌面的配置"><a href="#Ubuntu的桌面的配置" class="headerlink" title="Ubuntu的桌面的配置"></a>Ubuntu的桌面的配置</h2><ol><li><p>设置显示器 ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export  DISPLAY=localhost:0</span><br></pre></td></tr></table></figure></li><li><p>设置桌面参数,勾选了Ubuntu Unity Plugin 和 Window Management 下的 Place Window选项，其他的根据自己需要修改。设置完毕之后关闭即可;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccsm</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://begild-one.top/ccsm%E8%AE%BE%E7%BD%AE.png" alt="ccsm设置"></p><ol><li><p>展示桌面，运行下面指令。就可以在上面说的黑黑的界面上绘出桌面了。看起来是不是毫无违和感23333。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiz</span><br></pre></td></tr></table></figure><p><img src="http://begild-one.top/Ubuntu%E6%A1%8C%E9%9D%A2.png" alt="Ubuntu桌面"></p></li><li>做一个脚本便于设置和启动桌面。新建一个脚本放在根目录 <code>cd / &amp;&amp; sudo vi vcxsrv.sh</code> 将下面的代码粘贴到 vcxsrv.sh 里，再赋予执行权限 <code>chmod +x vcxsrv.sh</code> 。每次先用控制台进入 bash 运行脚本就OK了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">export  DISPLAY=localhost:0 #设置显示屏</span><br><span class="line">compiz</span><br></pre></td></tr></table></figure></li></ol><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>经过实测,8G内存，即使开启图形界面之后内存占用提升仅仅接近500M(31%–&gt;37%)，对比虚拟机(起码分配2G内存)少的就不止一点半点了好吧。确实是指的鼓捣的东西。</p><h2 id="已知的一些问题"><a href="#已知的一些问题" class="headerlink" title="已知的一些问题"></a>已知的一些问题</h2><ol><li>键盘的上下左右键值会被识别为数字8246，并且很鬼畜的识别为长按🤕，猜测原因：系统默认不开启数字键盘,导致识别错误但是识别为长按是什么鬼嘛。这一点很蛋疼。</li><li>刚启动桌面，桌面鼠标不可见或者会变成 × 号，解决办法：打开一个应用程序(非终端)后正常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞完Windows下Linux下子系统的启用，可以用命令行进行使用但是却是一个完全没有界面的系统。这样怎么能拼过虚拟机呢对吧。所以：图形界面启动！。
    
    </summary>
    
      <category term="linux" scheme="http://begild.top/categories/linux/"/>
    
    
      <category term="Linux子系统图形界面" scheme="http://begild.top/tags/Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Cmder 更好的选择</title>
    <link href="http://begild.top/article/ef68d1d8.html"/>
    <id>http://begild.top/article/ef68d1d8.html</id>
    <published>2018-04-19T06:35:31.000Z</published>
    <updated>2018-12-04T14:43:38.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="就如同封面一样，Cmder-看着就令人赏心悦目。微软自带-CMD-就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。"><a href="#就如同封面一样，Cmder-看着就令人赏心悦目。微软自带-CMD-就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。" class="headerlink" title="就如同封面一样，Cmder 看着就令人赏心悦目。微软自带 CMD 就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。"></a>就如同封面一样，Cmder 看着就令人赏心悦目。微软自带 CMD 就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。<a id="more"></a></h6><h2 id="Cmder安装"><a href="#Cmder安装" class="headerlink" title="Cmder安装"></a>Cmder安装</h2><ul><li><p>这是<a href="http://cmder.net/" target="_blank" rel="noopener">Cmder</a>官网，Cmder你可以选择两种版本，Mini和Full 这俩的区别我也不是很清楚，看网上说的也没有什么说服力🤔。我下载Full版本(zip100M)。<a href="https://github.com/cmderdev/cmder/releases/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>下载完毕之后直接解压到你喜欢的目录下面就 OK 了(自己建一个根目录啊他自己没有外封根目录的😅)，点击软件根目录下面的’Cmder.exe’即可启动 Cmder 软件。</p><p><img src="http://begild-one.top/cmder%E5%88%9D%E5%A7%8B%E6%89%93%E5%BC%80%E5%9B%BE.png" alt="cmder初始打开图"></p></li></ul><h2 id="添加-Cmder-环境变量"><a href="#添加-Cmder-环境变量" class="headerlink" title="添加 Cmder 环境变量"></a>添加 Cmder 环境变量</h2><ol><li><p>操作流程：此电脑—&gt;右键—&gt;属性(控制面板\所有控制面板项\系统)—&gt;侧边栏高级系统设置—&gt;右下角环境变量；</p></li><li><p>根据你的需要，是作为本用户使用还是作为全局其他用户也能使用选择添加为用户变量还是系统变量。找到<code>Path</code>变量条。<br>a. 双击，在弹出来的编辑窗口选择新建按钮，然后输入 ‘Cmder.exe’ 所在的路径；<br>b. 如果是win7貌似是直接编辑文本的吧,那就直接在最后面添加<code>;Cmder.exe 所在的路径</code> 我把 Cmder  安装在 <code>D:\cmder\</code> 下，结合起来就是<code>;D:\cmder\</code>。切记分号不能少🙂。<br><img src="http://begild-one.top/%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fcmder.png" alt="添加环境变量cmder"></p></li></ol><h2 id="添加右键-Cmder-Here"><a href="#添加右键-Cmder-Here" class="headerlink" title="添加右键 Cmder Here"></a>添加右键 Cmder Here</h2><p>这个是方便我们在任何文件夹直接打开 Cmder 。</p><ol><li>用管理员身份运行系统自带的 CMD，运行命令：<code>Cmder.exe /REGISTER ALL</code> (没有报错)。</li><li>任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Startup—&gt;Task ;</li><li>依次点击命令组下所有的命令任务在右下方的编辑框后面加<code>-new_console</code>  (前导空格别忘了) ;</li><li>关闭设置窗口~，设置完毕。在任意目录下右键即可看到 Cmder Here  字样的菜单。<br><img src="http://begild-one.top/cmder%20here%E8%AE%BE%E7%BD%AE.png" alt="Cmder Here设置"></li></ol><h2 id="自定义终端符号"><a href="#自定义终端符号" class="headerlink" title="自定义终端符号"></a>自定义终端符号</h2><p>这是个花里胡哨的操作😬。分为两个:  powershell 和 cmd .</p><ol><li>修改 cmd 的提示符：用文本编辑软件打开 软件根目录\vendor\clink.lua 文件，<ul><li>找到大概47行左右，两句话 <code>lambda = &quot;λ&quot;</code> 和  <code>lambda = &quot;(&quot;..env..&quot;) λ&quot;</code></li><li>替换 λ 为你喜欢的，我替换成 ღ (可以用搜狗特殊字符找一下自己喜欢的😹)。</li></ul></li><li>修改 powershell  的提示符：打开 clink.lua同级目录下的profile.ps1 文件。<ul><li>找到大概121行，Utility\Write-Host “`nλ “ -NoNewLine,</li><li>找到157行左右，两句话 <code>λ &lt;PostPrompt&gt; &lt;repl input&gt;</code> 和 <code>λ &lt;PostPrompt&gt;</code>  </li><li>将 λ 替换为你想要的。</li></ul></li><li>重启软件完成设置。</li></ol><h2 id="设置终端背景"><a href="#设置终端背景" class="headerlink" title="设置终端背景"></a>设置终端背景</h2><ol><li>任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Main—&gt;Background ;</li><li>勾选使用背景图像，在路径里找一张你喜欢的背景图片设置为背景 ;</li><li>在暗化调整(Darking)选项，可以调整图片的防止掩盖终端字体显示不清楚  ;</li><li>在放置方式管理(Placement)列表里可以选择你想把图片作何种放置(我设置的伸缩铺满窗口Stretch-Fill)。<br>你也可以通过背景插件 Far Manager 进行设置。<br><img src="http://begild-one.top/cmder%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF.png" alt="cmder设置背景"></li></ol><h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h2><p>使用默认的 cmder 中文会被识别为 <code>\数字</code> 的组合 根本没法看。</p><ol><li>任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Environment ;</li><li>在右侧编辑框里另起一行写入<code>set LC_ALL=zh_CN.UTF-8</code></li><li>完成设置，重启 cmder 生效。、<br>远程ssh连接服务器中文依然会乱码…。</li></ol><h2 id="配色主题"><a href="#配色主题" class="headerlink" title="配色主题"></a>配色主题</h2><ol><li>任意 Cmder 窗口—&gt;标题栏—&gt;右键—&gt;Settings…—&gt;Features—&gt;Colors ;</li><li>上方 Schemes 列表里选择你喜欢的配色方案~。</li></ol><h2 id="alias功能"><a href="#alias功能" class="headerlink" title="alias功能"></a>alias功能</h2><p>Cmder提供的 alias 功能可以让我们用较为简短易记的单词指令替代很长的语法指令。在终端输入指令 <code>alias</code> 即可查看别名对应的真正语法指令，可以通过<code>软件根目录\config\user-aliases.cmd</code> 写人自己需要用到的却又难记的语法指令和别名的对应式子。<br>比如我想要去我bolg所在的目录。每次都 cd 慢慢过去很烦，我就可以用 <code>blog =cd /d &quot;E:\GitHome\blog&quot;</code> 添加到 user-aliases.cmd 文件里，之后再终端直接输入blog就切换到blog的目录里。<br>登录服务器可以用这个配合putty实现<code>Tencent=&quot;D:\Program Files\PuTTY\plink.exe&quot; 255.255.255.255 -l root -pw &quot;12346578&quot;</code>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>cmder直接支持 ctrl+c 和 ctrl+v，在终端里双击选中即已经复制不需要用ctrl+c。</li><li>支持 vim 编辑器，同样的编辑方式和语法。</li><li>其他的一些设置诸如文字大小，默认启动也可以自行了解一下。</li><li>Cmder 核心就是基于 ConEmu 做的，不过外面加了大量的Linux下的工具命令。很多Linux的命令在上面都可以运行。</li></ol><p>cmder github地址: <a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">https://github.com/cmderdev/cmder</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;就如同封面一样，Cmder-看着就令人赏心悦目。微软自带-CMD-就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。&quot;&gt;&lt;a href=&quot;#就如同封面一样，Cmder-看着就令人赏心悦目。微软自带-CMD-就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。&quot; class=&quot;headerlink&quot; title=&quot;就如同封面一样，Cmder 看着就令人赏心悦目。微软自带 CMD 就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。&quot;&gt;&lt;/a&gt;就如同封面一样，Cmder 看着就令人赏心悦目。微软自带 CMD 就不谈了好吧，不过Windows本身就不是擅长用控制台和用户打交道的系统，所以这样也无可厚非吧。不过现在有了更好的选择：Cmder。
    
    </summary>
    
      <category term="Tools" scheme="http://begild.top/categories/Tools/"/>
    
    
      <category term="cmder" scheme="http://begild.top/tags/cmder/"/>
    
  </entry>
  
  <entry>
    <title>Win10下Linux子系统的启用</title>
    <link href="http://begild.top/article/40bf05cc.html"/>
    <id>http://begild.top/article/40bf05cc.html</id>
    <published>2018-04-19T04:19:13.000Z</published>
    <updated>2018-12-04T14:43:38.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。"><a href="#微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。" class="headerlink" title="微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。"></a>微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。<a id="more"></a></h5><h2 id="Linux子系统的获取"><a href="#Linux子系统的获取" class="headerlink" title="Linux子系统的获取"></a>Linux子系统的获取</h2><ul><li>在 ‘控制面板–&gt;程序和功能(侧边栏)–&gt;启用或关闭 Windows 功能–&gt;勾选适用于 Linux 的 Windows 子系统选项’。这样就成功使能 Linux 子系统的功能。（需要重启生效更新，请保存你的Word文档☠️…）我看到网上的教程说明需要选中 ‘设置–&gt;更新和安全–&gt;针对开发人员–&gt;开发人员模式’ 但我的选项是 ‘旁加载应用’ 也成功操作。</li><li>Linux子系统的获取可以用微软的应用商店进行安装。如下图是支持的子系统种类(2018.04.19)，我选择了Ubuntu 要使用其他系统的也看看，以后会支持更多的系统~ ~。<br><img src="http://begild-one.top/windows%E6%94%AF%E6%8C%81%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="windows支持的linux子系统"></li><li>就像装其他软件一样点击安装就会自动下载了。下载挺快的还📢，安装完毕之后就会显示启动这时候系统未被写入到磁盘里的。<br><img src="http://begild-one.top/%E4%B8%8B%E8%BD%BDubuntu.png" alt="下载ubuntu"></li><li>这样获取 Windows 下Linux子系统就完成了。点击启动会打开CMD运行然后将系统写入磁盘，所需时间并不长(SSD少于1分钟)长时间卡住尝试回车一下请求响应刷新界面。写入完毕会让你输入一个用户名(自定义哦不必须是 Windows  的用户名)和密码(不可见)。输入完毕就创建了一个用户，之后默认就是这个账户登录进系统。这个用户不具备管理员权限，如果你要默认使用管理员用户，那就直接关闭这个 CMD，就跳过这一步了。之后再打开就直接以 root 用户登录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Installing, this may take a few minutes...</span><br><span class="line">Installation successful!</span><br><span class="line">Please create a default UNIX user account. The username does not need to match your Windows username.</span><br><span class="line">For more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username: begild</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Default UNIX user <span class="built_in">set</span> to: begild</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">"root"</span>), use <span class="string">"sudo &lt;command&gt;"</span>.</span><br><span class="line"></span><br><span class="line">begild@BeGild-PC:~$</span><br></pre></td></tr></table></figure></li></ul><h2 id="Linux-子系统的位置"><a href="#Linux-子系统的位置" class="headerlink" title="Linux 子系统的位置"></a>Linux 子系统的位置</h2><ul><li>Linux子系统位于（Users == 用户 👎）:<br> <code>C:\Users\用户名\AppData\Local\Packages\含有Linux子系统名字的文件夹\LocalState\rootfs</code></li><li>我使用的账户是 Administrator 装的是 Ubuntu 那么位置就是:<br><code>C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</code></li><li>其他的系统和这个差不多，在 Packages 目录下找一下含有你安装的 Linux 子系统名字的文件夹就能找到。</li></ul><h2 id="Linux子系统位置的迁移"><a href="#Linux子系统位置的迁移" class="headerlink" title="Linux子系统位置的迁移"></a>Linux子系统位置的迁移</h2><p>因为linux子系统的位置式位于C盘的文件夹下面的，时间长了的话会产生大量的数据，C盘本来就装了Windows，现在加了一个Linux，两个系统的使用会导致C盘加速被塞满。所以，把C盘迁移到其他的数据盘是一个比较好的选择。当然你的C盘足够大任性选择也OK。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robocopy "子系统所有数据所在的位置" "迁移的目的地址" /E /COPYALL /XJ</span><br><span class="line"><span class="built_in">rmdir</span> "子系统所有数据所在的位置" /S /Q</span><br><span class="line">mklink /J "子系统所有数据所在的位置" "迁移的目的地址"</span><br></pre></td></tr></table></figure></p><p>我的子系统所有数据所在的位置是<br><code>C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</code><br>迁移的目的地址是 <code>D:\WSL</code><br>所以代码就是<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robocopy "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" "D:\WSL" /E /COPYALL /XJ</span><br><span class="line"><span class="built_in">rmdir</span> "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" /S /Q</span><br><span class="line">mklink /J "C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc" "D:\WSL"</span><br></pre></td></tr></table></figure></p><p>如果删除子系统数据目录的步骤(rmdir)  遇到不是空目录无法删除，重启电脑之后再执行就OK了。<br>执行上面的东西用 cmder 使用 ls 命令可以看到已经建立一个符号链接到目标目录了。这样就把东西全部迁移到 D:\WSL 里去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Packages</span><br><span class="line">ღ ls -l CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc</span><br><span class="line">lrwxrwxrwx 1 Administrator 197121 6 4月  22 14:10 CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc -&gt; /d/WSL/</span><br></pre></td></tr></table></figure></p><h2 id="Linux子系统的打开"><a href="#Linux子系统的打开" class="headerlink" title="Linux子系统的打开"></a>Linux子系统的打开</h2><ol><li>任意打开一个CMD窗口输入<code>bash</code> 启动一个Linux终端；</li><li>将 Ubuntu 固定到开始菜单磁贴，每次点击都能打开一个新的Linux终端窗口。</li></ol><h2 id="Linux子系统的一些信息"><a href="#Linux子系统的一些信息" class="headerlink" title="Linux子系统的一些信息"></a>Linux子系统的一些信息</h2><ol><li>使用<code>lsb_release -a</code> 可以看到系统的信息安装的是16.04.3长期支持版本</li><li><code>cat /proc/version</code> 可以看到内核版本 4.4.0-43-Microsoft;编译器GCC版本5.4.0<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@BeGild-PC:~<span class="comment"># lsb_release -a</span></span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 16.04.3 LTS</span><br><span class="line">Release:        16.04</span><br><span class="line">Codename:       xenial</span><br><span class="line">root@BeGild-PC:~<span class="comment"># uname -r</span></span><br><span class="line">4.4.0-43-Microsoft</span><br><span class="line">root@BeGild-PC:~<span class="comment">#  cat /proc/version</span></span><br><span class="line">Linux version 4.4.0-43-Microsoft (Microsoft@Microsoft.com) (gcc version 5.4.0 (GCC) ) <span class="comment">#1-Microsoft Wed Dec 31 14:42:53 PST 2014</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="换软件源"><a href="#换软件源" class="headerlink" title="换软件源"></a>换软件源</h2><p>emmm,将软件源换为国内源，这样更新和下载软件都会比较快一点。</p><ol><li><p>备份软件源列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv /etc/apt/sources.list /etc/apt/sources.list.bak</span></span><br></pre></td></tr></table></figure></li><li><p>编辑软件源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure></li><li><p>替换为国内源(我选<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学源</a>,可以去看看阿里源什么的)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></li><li><p>更新软件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure></li><li><p>更新软件,第一次会下载比较多的更新耐心等待。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get upgrade</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。&quot;&gt;&lt;a href=&quot;#微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。&quot; class=&quot;headerlink&quot; title=&quot;微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。&quot;&gt;&lt;/a&gt;微软在win10系统上添加了Linux子系统的支持，方便我们可以在windows上使用Linux，省去了占内存的虚拟机和双系统切换的麻烦😎，具体有什么和普通安装的Linux有什么不同，抱歉…不知道😬。
    
    </summary>
    
      <category term="linux" scheme="http://begild.top/categories/linux/"/>
    
    
      <category term="Win10下linux子系统" scheme="http://begild.top/tags/Win10%E4%B8%8Blinux%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STM32 Flash的读写</title>
    <link href="http://begild.top/article/31184d7e.html"/>
    <id>http://begild.top/article/31184d7e.html</id>
    <published>2018-03-07T15:26:39.000Z</published>
    <updated>2018-04-26T05:14:41.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。</p><h2 id="FLASH的写操作"><a href="#FLASH的写操作" class="headerlink" title="FLASH的写操作"></a>FLASH的写操作</h2><ol><li>FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’  ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。</li><li>写入操作(包括擦除)之前需要将FLASH解锁 <code>FLASH_Unlock()</code>，操作完成之后需要将FLASH上锁 <code>FLASH_Lock()</code> 。<a id="more"></a></li></ol><h2 id="正点原子的例子"><a href="#正点原子的例子" class="headerlink" title=" 正点原子的例子"></a><a href="http://www.alientek.com/" target="_blank" rel="noopener"> 正点原子</a>的例子</h2><ul><li>写入流程:<ul><li>解锁FLASH <code>FLASH_Unlock()</code>；</li><li>禁止数据缓存<code>FLASH_DataCacheCmd(DISABLE)</code>,根据你传入的起始地址 <code>WriteAddr</code> 和写入的字节数 <code>NumToWrite</code> 计算出结束地址 <code>endaddr</code>；</li><li>遍历整个写入范围，一旦发现非 ’1‘ 数据的出现就擦除整个扇区，他这里是字(Word)来检测的，所以地址 <code>addrx</code> 每次加4；</li><li>检测完毕并且擦除之后，进入写操作，每次写入一个字(4byte)的数据。所以 <code>WriteAddr</code> 每次加4, <code>u32 *pBuffer</code> 每次加1 ；</li><li>使能数据缓存<code>FLASH_DataCacheCmd(ENABLE)</code>，上锁FLASH <code>FLASH_Lock()</code>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//特别注意:因为STM32F4的扇区实在太大,没办法本地保存扇区数据,所以本函数</span></span><br><span class="line"><span class="comment">//     写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以</span></span><br><span class="line"><span class="comment">//     写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里</span></span><br><span class="line"><span class="comment">//     没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.</span></span><br><span class="line"><span class="comment">//该函数对OTP区域也有效!可以用来写OTP区!</span></span><br><span class="line"><span class="comment">//OTP区域地址范围:0X1FFF7800~0X1FFF7A0F</span></span><br><span class="line"><span class="comment">//WriteAddr:起始地址(此地址必须为4的倍数!!)</span></span><br><span class="line"><span class="comment">//pBuffer:数据指针</span></span><br><span class="line"><span class="comment">//NumToWrite:字(32位)数(就是要写入的32位数据的个数.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FLASH_Status status = FLASH_COMPLETE;</span><br><span class="line">    u32 addrx = <span class="number">0</span>;</span><br><span class="line">    u32 endaddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(WriteAddr &lt; STM32_FLASH_BASE || WriteAddr % <span class="number">4</span>)<span class="keyword">return</span>;<span class="comment">//非法地址</span></span><br><span class="line">    FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">    FLASH_DataCacheCmd(DISABLE);<span class="comment">//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line"></span><br><span class="line">    addrx = WriteAddr;<span class="comment">//写入的起始地址</span></span><br><span class="line">    endaddr = WriteAddr + NumToWrite * <span class="number">4</span>;<span class="comment">//写入的结束地址</span></span><br><span class="line">    <span class="keyword">if</span>(addrx &lt; <span class="number">0X1FFF0000</span>)<span class="comment">//只有主存储区,才需要执行擦除操作!!</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(addrx &lt; endaddr)<span class="comment">//扫清一切障碍.(对非FFFFFFFF的地方,先擦除)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(STMFLASH_ReadWord(addrx) != <span class="number">0XFFFFFFFF</span>) <span class="comment">//有非0XFFFFFFFF的地方,要擦除这个扇区</span></span><br><span class="line">        &#123;</span><br><span class="line">        status = FLASH_EraseSector(STMFLASH_GetFlashSector(addrx), VoltageRange_3); <span class="comment">//VCC=2.7~3.6V之间!!</span></span><br><span class="line">        <span class="keyword">if</span>(status != FLASH_COMPLETE)<span class="keyword">break</span>;<span class="comment">//发生错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> addrx += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status == FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(WriteAddr &lt; endaddr) <span class="comment">//写数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FLASH_ProgramWord(WriteAddr, *pBuffer) != FLASH_COMPLETE) <span class="comment">//写入数据</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//写入异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        WriteAddr += <span class="number">4</span>;</span><br><span class="line">        pBuffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_DataCacheCmd(ENABLE);<span class="comment">//FLASH擦除结束,开启数据缓存</span></span><br><span class="line">    FLASH_Lock();<span class="comment">//上锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试和分析<br>经过实验，擦除扇区的时间是很久的，擦除128KByte的扇区大概需要1s多。并且，不解锁虽然可以通过擦除函数并且返回 <code>FLASH_COMPLETE</code> 但是实际并没有擦除成功。我开始以为他这个耗时主要体现在读和判断，擦除操作比较快，😒但其实读120KByte的数据只需要3.9ms加上判断的时间也没多少主要的时间耗费在擦除操作上。😆另一个体现就是如果在 Keil 的工程选项里把擦除全部flash勾选，下载前的擦除的时间是很长的。下面是测试代码和解释结果。测试结果可以看出，擦除的时间并没有很大变化，因为都是需要一次性操作一个扇区，只要不超过一个扇区的长度都不会变化很大。写入和读出的时间保持线性变化。所有的测试都是用原子官方例程按照WORD(32bit)来写入的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...上续代码</span><br><span class="line">  STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);<span class="comment">//写入一些数据保证flash不全为'1'</span></span><br><span class="line">  uprintf(USART1, <span class="string">"扇区预先不为全 '1'时写入:\r\n"</span>);</span><br><span class="line">  uprintf(USART1, <span class="string">"写入长度:%d\r\n"</span>, TEXT_LENTH);</span><br><span class="line">  <span class="comment">//原子的例子擦除flash再写入数据</span></span><br><span class="line">  STMFLASH_Write(FLASH_SAVE_ADDR, (u32 *)&amp;txbuf, SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(readbuf,<span class="number">0</span>,TEXT_LENTH);<span class="comment">//清空数据读取</span></span><br><span class="line">  StartTiming();</span><br><span class="line">  STMFLASH_Read(FLASH_SAVE_ADDR, (u32 *)&amp;readbuf, SIZE);</span><br><span class="line">  timems = GetTimeMs();</span><br><span class="line">  uprintf(USART1, <span class="string">"读出耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">  uprintf(USART1, <span class="string">"读出长度:%d\r\n----\r\n"</span>, TEXT_LENTH, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)readbuf));</span><br><span class="line">...下续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr, u32 *pBuffer, u32 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...上续代码</span><br><span class="line">  FLASH_DataCacheCmd(DISABLE);<span class="comment">//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line">  StartTiming();<span class="comment">//开始计时擦除扇区耗时</span></span><br><span class="line">.....上续代码</span><br><span class="line">timems = GetTimeMs(); </span><br><span class="line">uprintf(USART1,<span class="string">"擦除扇区耗时 :%.3fms\r\n"</span>,timems);</span><br><span class="line">StartTiming();<span class="comment">//开始写入计时</span></span><br><span class="line">    <span class="keyword">if</span>(status == FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">...上续代码</span><br><span class="line"> FLASH_Lock();<span class="comment">//上锁</span></span><br><span class="line"> timems = GetTimeMs();<span class="comment">//获取写入耗时</span></span><br><span class="line"> uprintf(USART1, <span class="string">"写入耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*测试结果 测试120、12K、120K(Byte)的数据*/</span></span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">120</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1046.720</span>ms</span><br><span class="line">写入耗时:<span class="number">0.440</span>ms</span><br><span class="line">读出耗时:<span class="number">0.020</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">12288</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1050.220</span>ms</span><br><span class="line">写入耗时:<span class="number">45.700</span>ms</span><br><span class="line">读出耗时:<span class="number">0.380</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1051.860</span>ms</span><br><span class="line">写入耗时:<span class="number">458.700</span>ms</span><br><span class="line">读出耗时:<span class="number">3.880</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">----</span><br></pre></td></tr></table></figure><h2 id="改进擦除方式"><a href="#改进擦除方式" class="headerlink" title="改进擦除方式"></a>改进擦除方式</h2><ul><li>改进的一点想法<br>根据正点原子的测试结果来看，擦除扇区的时间是不可避免的，无非就是暴力一点不检测直接擦除(因为通常来说，如果你存储在固定的flash地址除了第一次之后都会有数据)。这样搞了之后从测试的结果来看提升并不明显。写120KByte的数据下擦除时间少了4ms左右😔(少了读取和判断的时间)。所以擦除的方式并没有很好的改进方法(标题党😈)。</li></ul><h2 id="通用性考虑"><a href="#通用性考虑" class="headerlink" title="通用性考虑"></a>通用性考虑</h2><ul><li>通过正点原子的例子熟悉了Flash的读写，但是只支持4字节对齐(WORD)的操作,我看了一下库的函数是可以支持 BYTE，HALFWORD,WORD, 和 DOUBLEWORD 的，不过 DOUBLEWORD 需要外部Vpp。所以想改进一些支持库函数里的各种byte(1-4) 的操作。</li><li>修改好之后测试一下测试代码和上面原版的差不多。只是写入函数换成了修改之后的<code>STMFLASH_WriteWithErase</code>，测试结果如下,测试的时候用的是WORD方式写入。和原子基本没有差别。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">120</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1043.500</span>ms</span><br><span class="line">写入耗时:<span class="number">0.460</span>ms</span><br><span class="line">读出耗时:<span class="number">0.000</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">12288</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1046.580</span>ms</span><br><span class="line">写入耗时:<span class="number">45.700</span>ms</span><br><span class="line">读出耗时:<span class="number">0.400</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> </span><br><span class="line">----</span><br><span class="line">扇区预先不为全 <span class="string">'1'</span>时写入:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1050.860</span>ms</span><br><span class="line">写入耗时:<span class="number">459.140</span>ms</span><br><span class="line">读出耗时:<span class="number">3.900</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">----</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他ByteSize方式写入"><a href="#其他ByteSize方式写入" class="headerlink" title="其他ByteSize方式写入"></a>其他ByteSize方式写入</h2><p>相对于用WORD来说用其他方式写入flash是要慢一些的。采用 BYTE 方式需要 大概<code>1832ms</code>,采用HALFWORD方式需要<code>920ms</code>左右。因为擦除都是采用的<code>VoltageRange_3</code>也就是WORD方式所以擦除时间差不多。</p><h2 id="分离操作的方式"><a href="#分离操作的方式" class="headerlink" title="分离操作的方式"></a>分离操作的方式</h2><ul><li>分离操作的意义<br>把擦除和写入分开。考虑到一个扇区是非常大的，一个扇区可能会存储多种数据。如果写入之前有数据就会导致整个扇区被擦除，数据就会丢失。所以采用分离的办法，把数据的写入和擦除分隔开，根据需要选择是否擦除扇区内的数据，保证在擦除的操作之前有相应的备份操作就OK了。这样即使忘记擦除那么也只是新的数据没法正确写到flash里面，其他部分的数据就不会被擦除，这样有利于更好的数据完整性。</li><li>测试结果和测试代码,经过测试分离之后的操作和没分离的时间上基本没什么差别，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">分离操作方式写入flash:</span><br><span class="line">擦除扇区耗时:<span class="number">1023.320</span>ms</span><br><span class="line">写入长度:<span class="number">120</span> byte</span><br><span class="line">写入耗时:<span class="number">0.440</span>ms</span><br><span class="line">读出耗时:<span class="number">0.000</span>ms</span><br><span class="line">读出长度:<span class="number">120</span> byte</span><br><span class="line">****</span><br><span class="line">分离操作方式写入flash:</span><br><span class="line">擦除扇区耗时:<span class="number">1015.140</span>ms</span><br><span class="line">写入长度:<span class="number">12288</span> byte</span><br><span class="line">写入耗时:<span class="number">45.940</span>ms</span><br><span class="line">读出耗时:<span class="number">0.400</span>ms</span><br><span class="line">读出长度:<span class="number">12288</span> byte</span><br><span class="line">****</span><br><span class="line">合并操作方式写入flash:</span><br><span class="line">写入长度:<span class="number">122880</span></span><br><span class="line">擦除扇区耗时 :<span class="number">1010.480</span>ms</span><br><span class="line">写入耗时:<span class="number">461.420</span>ms</span><br><span class="line">读出耗时:<span class="number">3.900</span>ms</span><br><span class="line">读出长度:<span class="number">122880</span> </span><br><span class="line">****</span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>）</span><br><span class="line">&#123;</span><br><span class="line">...上续代码</span><br><span class="line">    uprintf(USART1, <span class="string">"分离操作方式写入flash:\r\n"</span>);</span><br><span class="line">    StartTiming();</span><br><span class="line">    status = StmEraseFlashSector(FLASH_SAVE_ADDR, TEXT_LENTH);</span><br><span class="line">    <span class="comment">//FLASH_DataCacheCmd(DISABLE);//FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line">    <span class="comment">//status = FLASH_EraseSector(STMFLASH_GetFlashSector(FLASH_SAVE_ADDR), VoltageRange_3); //VCC=2.7~3.6V之间!!</span></span><br><span class="line">    <span class="keyword">if</span>(status != FLASH_COMPLETE)</span><br><span class="line">    &#123;</span><br><span class="line">        uprintf(USART1, <span class="string">"擦除扇区失败:%d\r\n"</span>,status);    <span class="comment">//发生错误了</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"擦除扇区耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">uprintf(USART1, <span class="string">"写入长度:%d byte\r\n"</span>, TEXT_LENTH);</span><br><span class="line">    StartTiming();</span><br><span class="line">    <span class="comment">//不需要擦除falsh直接写数据</span></span><br><span class="line">    STMFLASH_WriteNoErase(FLASH_SAVE_ADDR, txbuf,TEXT_LENTH,ByteSize);</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"写入耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line"><span class="built_in">memset</span>(readbuf,<span class="number">0</span>,TEXT_LENTH);<span class="comment">//清空数据读取</span></span><br><span class="line">    StartTiming();</span><br><span class="line">    STMFLASH_Read(FLASH_SAVE_ADDR,readbuf, TEXT_LENTH,ByteSize);</span><br><span class="line">    timems = GetTimeMs();</span><br><span class="line">    uprintf(USART1, <span class="string">"读出耗时:%.3fms\r\n"</span>, timems);</span><br><span class="line">    uprintf(USART1, <span class="string">"读出长度:%d byte\r\n****\r\n"</span>, TEXT_LENTH, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)readbuf)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搞了几天才把这个写完整。中途也进了好多的坑，浪费了好长时间。不过还是写完了。说一点注意的地方</p><ul><li>flash的写入地址不是偶数就可以，得是4的倍数。</li><li>无论是擦除还是写入都需要先解锁flash。读取则不需要。</li><li>对于同一个扇区的建议用分离的操作，并且在操作前根据需要把其他的数据读出来备份一下在写进去。</li></ul><p>关于本文的代码详见于<a href="https://coding.net/u/BycCoding/p/stm32f4_flash/git" target="_blank" rel="noopener">Coding项目</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记一下STM32F4板子FLASH的读写操作以及需要注意的地方。&lt;/p&gt;
&lt;h2 id=&quot;FLASH的写操作&quot;&gt;&lt;a href=&quot;#FLASH的写操作&quot; class=&quot;headerlink&quot; title=&quot;FLASH的写操作&quot;&gt;&lt;/a&gt;FLASH的写操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;FLASH由 ‘1’ 变为 ‘0’ 不能由 ‘0’ 变为 ‘1’ ，所以在写入之间需要检测是否为 ‘1’  ,并且擦除flash只能按照一个扇区来删除，由上可知，我们写入之前必须确保我们需要写入的地址读回来的值是0XFF，如果不是0XFF就需要将整个扇区擦除(扇区变为全 ‘1’ )。&lt;/li&gt;
&lt;li&gt;写入操作(包括擦除)之前需要将FLASH解锁 &lt;code&gt;FLASH_Unlock()&lt;/code&gt;，操作完成之后需要将FLASH上锁 &lt;code&gt;FLASH_Lock()&lt;/code&gt; 。
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="Flash读写" scheme="http://begild.top/tags/Flash%E8%AF%BB%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>STM32自定义串口printf</title>
    <link href="http://begild.top/article/a854db16.html"/>
    <id>http://begild.top/article/a854db16.html</id>
    <published>2018-03-01T12:29:34.000Z</published>
    <updated>2018-07-22T01:46:05.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。</p><hr><h2 id="重定向-printf-函数"><a href="#重定向-printf-函数" class="headerlink" title="重定向 printf 函数"></a>重定向 printf 函数</h2><p>对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义fputc函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">    USART1-&gt;DR = (u8) ch;</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="自定义printf函数"><a href="#自定义printf函数" class="headerlink" title="自定义printf函数"></a>自定义printf函数</h2><p>但是我们如果使用多个串口或者说串口输出不一定总从串口1输出怎么办呢。这时候这样就没法实现，后来上网查一下我们可以自己实现printf这个函数。命名为uprintf，接收至少两个参数，第1个参数是串口号;第2个是格式化字符串;第3-n ‘ … ‘ 是参数匹配列表， 实现变长的参数列表接收。。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(<span class="number">300</span>); <span class="comment">//申请缓冲区</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">//找第一个可变形参的地址，并把地址赋给ap</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(s_string, fmt, ap); <span class="comment">//类似sprintf函数</span></span><br><span class="line">    USART_String(USARTx, s_string); <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个函数里的过程:</p><ol><li>通过 va_start 函数获得参数列表里每个项和格式化字符里对应的位置，形成一个列表 ap 。</li><li>通过 vsprintf 把列表里每个参数转为字符串写到 s_string 字符串里。</li><li>通过 USART_String 发送到串口。</li><li>释放列表 ap 和 发送缓冲 s_string 。</li></ol><h2 id="完整的一个自定义printf实现文件"><a href="#完整的一个自定义printf实现文件" class="headerlink" title="完整的一个自定义printf实现文件"></a>完整的一个自定义printf实现文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uart_x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdarg.h"</span></span></span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendByte</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">unsigned</span> <span class="keyword">char</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((USARTx-&gt;SR &amp; <span class="number">0X40</span>) == <span class="number">0</span>) &#123;&#125;; <span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">    USARTx-&gt;DR = (u8) dat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_String</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s != <span class="string">'\0'</span>)<span class="comment">// '\0' 表示字符串结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        SendByte(USARTx, *s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(<span class="number">300</span>); <span class="comment">//申请空间</span></span><br><span class="line">    va_start(ap, fmt); /找第一个可变形参的地址，并把地址赋给ap</span><br><span class="line">    <span class="built_in">vsprintf</span>(s_string, fmt, ap); <span class="comment">//类似sprintf函数</span></span><br><span class="line">    USART_String(USARTx, s_string);  <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数已经能满足多个串口同时使用printf，根据自己的需求可以修改申请的缓冲区大小即可。</p><h2 id="安全版本的自定义-printf-实现"><a href="#安全版本的自定义-printf-实现" class="headerlink" title="安全版本的自定义 printf 实现"></a>安全版本的自定义 printf 实现</h2><p>但上面的实现并不是安全的，如果你发送的字符串长度大于缓冲区长度就会造成内存溢出。所以你可以更改为一个安全的版本，接收一个缓冲区长度参数从而申请一个合适大小的空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用串口写一个printf函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uprintf_s</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint32_t</span> BuffSize,<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">//typedef char *va_list; va_list是char型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *s_string = <span class="built_in">malloc</span>(BuffSize); <span class="comment">//申请空间</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">//找第一个可变形参的地址，并把地址赋给ap</span></span><br><span class="line">    vsprintf_s(s_string,BuffSize, fmt, ap);<span class="comment">//类似sprintf_s函数</span></span><br><span class="line">    USART_String(USARTx, s_string); <span class="comment">//发送和整个字符串</span></span><br><span class="line">    va_end(ap); <span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">free</span>(s_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>使用 printf 大法非常方便，但是尽量避免在中断里调用该函数(执行 printf 需要的时间比较久),以及调试完毕之后注释掉相关的代码，缩短功能代码的执行时间。</li><li>有兴趣的可以写 printf 到 OLED 之类的函数，原理都是一样，实现屏幕位置控制和最后的写一个字节的函数就能完成移植。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;硬件的调试通常可分为两大类，一种是用调试器将芯片和电脑连接通过单步等方式逐步运行进行调试，另一种就是printf大法在程序运行过程中输出调试信息。第一种比较深入，可以了解每一个变量，栈堆，函数等等的变化是比较系统化的调试。但我通常都是用printf来调试的，因为快速简单属于非介入的方式，调试完毕直接注释掉相关部分就行了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;重定向-printf-函数&quot;&gt;&lt;a href=&quot;#重定向-printf-函数&quot; class=&quot;headerlink&quot; title=&quot;重定向 printf 函数&quot;&gt;&lt;/a&gt;重定向 printf 函数&lt;/h2&gt;&lt;p&gt;对于STM32来说现在串口例程一般都配有一个printf重定向到串口1的代码，直接可以使用printf很方便的输出信息到串口上。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//重定义fputc函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fputc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ch, FILE *f)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((USART1-&amp;gt;SR&amp;amp;&lt;span class=&quot;number&quot;&gt;0X40&lt;/span&gt;)==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//循环发送,直到发送完毕&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    USART1-&amp;gt;DR = (u8) ch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="串口(UART)" scheme="http://begild.top/tags/%E4%B8%B2%E5%8F%A3-UART/"/>
    
  </entry>
  
  <entry>
    <title>SMT32串口接收、空闲中断</title>
    <link href="http://begild.top/article/977ab4d9.html"/>
    <id>http://begild.top/article/977ab4d9.html</id>
    <published>2018-03-01T07:20:12.000Z</published>
    <updated>2018-04-26T05:14:42.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="识别尾进行接收结束的验证"><a href="#识别尾进行接收结束的验证" class="headerlink" title="识别尾进行接收结束的验证"></a>识别尾进行接收结束的验证</h2><ol><li>串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXUSART1BUFSIZE 200</span></span><br><span class="line"><span class="keyword">uint8_t</span> Uart1_BUF[MAXUSART1BUFSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//串口1中断服务程序               </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">uint32_t</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  </span><br><span class="line">  &#123;</span><br><span class="line">    RecByte = USART1-&gt;DR;<span class="comment">//读取接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; MAXUSART1BUFSIZE)<span class="comment">//防止内存溢出</span></span><br><span class="line">      Uart1_BUF[pos++] = RecByte;</span><br><span class="line">    <span class="keyword">if</span>(RecByte == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> 接收完毕相关处理</span></span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="识别头尾进行数据段的保护"><a href="#识别头尾进行数据段的保护" class="headerlink" title="识别头尾进行数据段的保护"></a>识别头尾进行数据段的保护</h2><ol><li>上面的方法就是发送的时候麻烦一点，每次都需要在后面加 ‘*‘, 并且如果发送错一次(忘记加 ‘*’)就会把缓冲区的内容累计到下一次(可以添加头识别进行解决)。这样就只会识别指定的数据段。一般这样适用于发送带有意义的控制数据保证数据不多收也不少收。验证的字符要保证不会出现在内容里，或者用多个字符进行验证。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXUSART1BUFSIZE 200</span></span><br><span class="line"><span class="keyword">uint8_t</span> Uart1_BUF[MAXUSART1BUFSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">uint32_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RecByte = USART1-&gt;DR;<span class="comment">//读取接收到的数据</span></span><br><span class="line">        <span class="keyword">if</span>(RecByte == <span class="string">'#'</span>)</span><br><span class="line">            pos = <span class="number">1</span>; <span class="comment">//开始接收数据</span></span><br><span class="line">        <span class="keyword">if</span>(pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; MAXUSART1BUFSIZE)<span class="comment">//防止内存溢出</span></span><br><span class="line">                Uart1_BUF[pos - <span class="number">1</span>] = RecByte;</span><br><span class="line">            pos ++;</span><br><span class="line">            <span class="keyword">if</span>(RecByte == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> 接收完毕相关处理</span></span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="STM32空闲中断的配置"><a href="#STM32空闲中断的配置" class="headerlink" title="STM32空闲中断的配置"></a>STM32空闲中断的配置</h2><ol><li><p>前几天做项目也要用到串口传输控制信息在STM32上的话可以利用串口空闲中断(接收完字符以后在下一个传输字符的时间内没有字符传来)来接收数据，这样就不用像上面那样做特定的识别，也比较方便。在这里备注一下，因为当时一开始配置完了并不起作用，后来上网查证了最后才找到解决办法。初始化的代码就不贴了，主要是最后配置完毕，开中断的代码贴一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...上续初始化的相关配置</span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure); <span class="comment">//初始化串口</span></span><br><span class="line">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启中断</span></span><br><span class="line">USART_ITConfig(USART1, USART_IT_IDLE,ENABLE);<span class="comment">//开启中断</span></span><br><span class="line"><span class="comment">//USART_ClearITPendingBit(USART1, USART_IT_IDLE |USART_IT_RXNE);//清除中断</span></span><br><span class="line">USART_Cmd(USART1, ENABLE);                    <span class="comment">//使能串口</span></span><br></pre></td></tr></table></figure></li><li><p>一开始我使用的是下面这条语句进行中断配置的，发现并不能触发空闲中断，后来才知道<font color="#ff0000" size="5">必须要分两次</font>才能正确配置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1, USART_IT_RXNE | USART_IT_IDLE, ENABLE);<span class="comment">//开启中断</span></span><br></pre></td></tr></table></figure></li><li><p>查看了一下<font color="#00cccc" size="5">USART_ITConfig()</font>函数的源码才看出来，他这个函数为了USART_IT_IDLE等中断宏定义的通用性，必须每次只能初始化一个中断标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint16_t</span> USART_IT, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">/* Get the interrupt position */</span></span><br><span class="line">    itpos = USART_IT &amp; IT_Mask;</span><br><span class="line">    itmask = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; itpos);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*相关计算</span></span><br><span class="line"><span class="comment">#define USART_IT_IDLE      ((uint16_t)0x0424)</span></span><br><span class="line"><span class="comment">#define IT_Mask            ((uint16_t)0x001F)  //!&lt; USART Interrupt Mask </span></span><br><span class="line"><span class="comment">itpos = 0x0424 &amp; 0x001F = 0x04;</span></span><br><span class="line"><span class="comment">itmask = (((uint32_t)0x01) &lt;&lt; itpos) = 0x10;</span></span><br><span class="line"><span class="comment">0x10 = 0b00010000//bit[4];</span></span><br><span class="line"><span class="comment">查阅官方的手册可以看到空闲中断使能也恰好就是bit[4];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>究其原因是因为itmask这个变量其实就是中断位于寄存器的位置，他是一个0bxx1xx的变量。只能表示一个中断标志位所以每次只能初始化一个标志位。</p></li></ol><h2 id="STM32空闲中断服务函数"><a href="#STM32空闲中断服务函数" class="headerlink" title="STM32空闲中断服务函数"></a>STM32空闲中断服务函数</h2><ol><li><p>接下来就是中断服务函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> USART1RecBuf[USART1RecBufMaxSize];<span class="comment">//接收缓冲区</span></span><br><span class="line"><span class="keyword">uint8_t</span> sdfsdf = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>      <span class="comment">//串口1中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint16_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET) <span class="comment">//接收完毕触发空闲中断</span></span><br><span class="line">    &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">      USART1-&gt;DR;<span class="comment">//清除空闲中断标志位</span></span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> 中断接收完成标志</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> RecByte;</span><br><span class="line">        Res = USART1-&gt;DR; <span class="comment">//读取接收到的数据</span></span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= USART1RecBufMaxSize) <span class="comment">//超过范围返回</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        USART1RecBuf[pos++] = RecByte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里需要注意的就是空闲中断的清除并不是调用USART_ClearITPendingBit()函数来清除,查看库的函数源码实现也可以看到注释里并没有说明 USART_IT_IDLE 该参数是可以被传入的，并且我们使用 <font color="#00cccc" size="3">USART1-&gt;DR</font> 就能清除串口空闲中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">  * @param  USART_IT: specifies the interrupt pending bit to clear.</span></span><br><span class="line"><span class="comment">  *   This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_LBD:  LIN Break detection interrupt</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_TC:   Transmission complete interrupt.</span></span><br><span class="line"><span class="comment">  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef *USARTx, <span class="keyword">uint16_t</span> USART_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">····</span><br></pre></td></tr></table></figure></li><li><p>到此完成了串口空闲中断的配置，之后只要两次接收数据之间的时间大于一个字符的时间(跟波特率有关),就能触发这个中断。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;识别尾进行接收结束的验证&quot;&gt;&lt;a href=&quot;#识别尾进行接收结束的验证&quot; class=&quot;headerlink&quot; title=&quot;识别尾进行接收结束的验证&quot;&gt;&lt;/a&gt;识别尾进行接收结束的验证&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;串口接收完毕标志可以利用识别特定字符(字符串)来检测，比如 “\r\n”、’*#’ 之类的。所以每次发数据都需要加上这些字符才能被识别为接收完毕，这样好处就是比较通用。无论是什么硬件平台都能用。代码也不复杂，在STM32平台上简单的例子如下代码段：当接收到 ‘*‘ 时候就会置位接收完成标志位，就可以进行处理了。&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAXUSART1BUFSIZE 200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; Uart1_BUF[MAXUSART1BUFSIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;USART1_IRQHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; 	&lt;span class=&quot;comment&quot;&gt;//串口1中断服务程序               &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; RecByte;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; pos = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RecByte = USART1-&amp;gt;DR;&lt;span class=&quot;comment&quot;&gt;//读取接收到的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pos &amp;lt; MAXUSART1BUFSIZE)&lt;span class=&quot;comment&quot;&gt;//防止内存溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Uart1_BUF[pos++] = RecByte;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(RecByte == &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//&lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; 接收完毕相关处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pos = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://begild.top/categories/STM32/"/>
    
    
      <category term="串口(UART)" scheme="http://begild.top/tags/%E4%B8%B2%E5%8F%A3-UART/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266工程的裁剪和编译</title>
    <link href="http://begild.top/article/2e11c696.html"/>
    <id>http://begild.top/article/2e11c696.html</id>
    <published>2018-01-23T08:35:39.000Z</published>
    <updated>2018-04-26T05:14:42.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。</p><h2 id="模板工程所需文件"><a href="#模板工程所需文件" class="headerlink" title="模板工程所需文件"></a>模板工程所需文件</h2><p>由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。<br><a id="more"></a><br><img src="https://s1.ax1x.com/2018/01/23/pIQc7j.png" alt="1.png">  </p><p>我们需要把这个工程做成一个最基本的模板那么就需要把里面冲突的和暂时不需的都给删除。如下图是需要裁剪的内容： 红色的是需要删除的。紫色的删了节省空间。<br><img src="https://s1.ax1x.com/2018/01/23/pI1hOU.png" alt="2.png"><br>所以我们把刚刚标记这些都全部删除(别忘了备份一个原版的以后用)之后，这样就会少了很多东西。<br>那现在可以编译了吗？打扰了，并不行。因为makefile这个神奇的东西存在，所以我们需要做一些调整和更改使得makefile能正确的识别、编译、链接整个工程。至于makefile是什么东西大家上网搜查看！这里就不展开讲了，因为就那个就可以做一个专题23333。<br>你暂时只需要知道编译整个工程需要它掌控整个工程的各个文件的信息和关系的，所以我们需要告诉它各个文件的信息和之间的关系，所幸的是官方给的makefile已经很通用了，我们稍微做改变就可以了(感谢ing…)</p><h2 id="模板工程文件的调整"><a href="#模板工程文件的调整" class="headerlink" title="模板工程文件的调整"></a>模板工程文件的调整</h2><p>下面的操作就是属于比较灵性的，不要问我为什么因为我个人觉得这样比较好。先按照我的来，等你学会了就可以去装逼了。先约定”/“就是工程的根目录，用绝对路径目录有点长。  </p><ol><li>剪切 /driver_lib/driver —&gt; /examples/project_template/</li><li>剪切 /driver_lib/include/ 的所有头文件 —&gt; /examples/project_template/include/</li><li>改名 /examples/project_template —&gt; app</li><li>复制 /examples/app —&gt; /</li><li>删除 /app/sample_lib 目录</li><li>删除 /driver_lib 目录  </li><li>删除 /examples 目录</li></ol><p>这样就完成了工程文件的调整：把相关的硬件驱动移到app目录下面，并且删除了示例的库。调整完成之后的目录如下图(documents目录删不删不影响)：<br><img src="https://s1.ax1x.com/2018/01/23/pouGqJ.png" alt="3.png">  </p><h2 id="MakeFile文件的修改"><a href="#MakeFile文件的修改" class="headerlink" title="MakeFile文件的修改"></a>MakeFile文件的修改</h2><ol><li>修改/Makefile文件<ul><li>文件里添加两句话<font color="#ff0000" size="5">SDK_PATH=××× BIN_PATH=xxx </font>比如我的工程根目录在<font color="#00ccff" size="3"> “ e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template “</font>那么我的文件修改如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="keyword">ifndef</span> PDIR</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">SDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line">BIN_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(COMPILE)</span>, xcc)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>2.修改/app/Makefile文件</p><ul><li>文件里添加一句话<font color="#ff0000" size="5">SDK_PATH=×××</font> 添加在文件的17行左右，内容就是你工程的根目录。</li><li>文件里的<font color="#ff0000" size="5">SUBDIR=×××</font> 把所有包含了c文件的子目录都添加进去。(‘\’表示续一行)，ctrl+f可快速查找，修改位置大概在23行左右。</li><li><p>修改完成之后如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...上续</span><br><span class="line"><span class="comment">#FLAVOR = release</span></span><br><span class="line">FLAVOR = debug</span><br><span class="line">SDK_PATH=e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line"><span class="comment">#EXTRA_CCFLAGS += -u</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifndef</span> PDIR <span class="comment"># &#123;</span></span><br><span class="line">GEN_IMAGES= eagle.app.v6.out</span><br><span class="line">GEN_BINS= eagle.app.v6.bin</span><br><span class="line">SPECIAL_MKTARGETS=<span class="variable">$(APP_MKTARGETS)</span></span><br><span class="line">SUBDIRS=    \</span><br><span class="line">    user    \</span><br><span class="line">    driver</span><br><span class="line"><span class="keyword">endif</span> <span class="comment"># &#125; PDIR</span></span><br><span class="line">...下续</span><br></pre></td></tr></table></figure></li><li><p>把<font color="#ff0000" size="5">COMPONENTS_eagle.app.v6=×××</font> 需要的.a文件修改为子目录下生成对应的.a文件(听不懂没关系，看效果代码)，大概在48行左右。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...上续</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(FLAVOR)</span>,release)</span><br><span class="line">TARGET_LDFLAGS += -g -O0</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">COMPONENTS_eagle.app.v6 = \</span><br><span class="line">    user/libuser.a  \</span><br><span class="line">    driver/libdriver.a </span><br><span class="line">LINKFLAGS_eagle.app.v6 = \</span><br><span class="line">    -L<span class="variable">$(SDK_PATH)</span>/lib        \</span><br><span class="line">    -Wl,--gc-sections   \</span><br><span class="line">...下续</span><br></pre></td></tr></table></figure></li></ul><p>这样就修改完成了。  </p><h2 id="工程的编译"><a href="#工程的编译" class="headerlink" title="工程的编译"></a>工程的编译</h2><ol><li>左键点击工程名选中工程-&gt;右键弹出菜单-&gt;BuildProject 即可编译。如果出现BuildProject选项灰色就是你没选中。如果失败可以尝试CleanProject(就在BuildProject下面)一下工程再编译。</li><li>编译之后输出窗口大致如下，输出两个bin文件：eagle.flash.bin 和 eagle.irom0text.bin ,这样就完成了工程的编译。这个固件是不支持OTA升级的，所以也不需要boot。也没有user1.bin和user2.bin。所以不要觉得奇怪。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">23:48:32 **** Incremental Build of configuration Default for project ESP8266_RTOS_SDK-1.5-project_template ****</span><br><span class="line">make all </span><br><span class="line">make[1]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;</span><br><span class="line">make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;</span><br><span class="line">make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/user&apos;</span><br><span class="line">make[2]: Entering directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;</span><br><span class="line">make[2]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app/driver&apos;</span><br><span class="line"></span><br><span class="line">!!!</span><br><span class="line">SDK_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template</span><br><span class="line">BIN_PATH: e:/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/bin</span><br><span class="line"></span><br><span class="line">No boot needed.</span><br><span class="line">Generate eagle.flash.bin and eagle.irom0text.bin successully in BIN_PATH</span><br><span class="line">eagle.flash.bin--------&gt;0x00000</span><br><span class="line">eagle.irom0text.bin----&gt;0x20000</span><br><span class="line">!!!</span><br><span class="line">make[1]: Leaving directory &apos;/cygdrive/e/esp8266/leixing/ESP8266_RTOS_SDK-1.5-project_template/app&apos;</span><br><span class="line"></span><br><span class="line">23:48:37 Build Finished (took 4s.472ms)</span><br></pre></td></tr></table></figure></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇说的可能看起来有点云里雾里。因为和平时大家用的的不需要自己编写编译规则的IDE不同。像keil的话你添加的头文件也需要的手动添加到工程的IncludePath里面去。但是用这个eclipse开发esp8266完全使用makefile控制的，你的目录，头文件，c文件都是需要你手动配置makefile的，道理都一样都是要告诉编译器怎么去编译链接文件。不过是你自己找到makefile添加而已。之后会专门有一篇大概说一下整个工程如果我们想添加新的功能文件夹(比如实现一个tcp客户端功能)，我们怎么去修改makefile。有什么疑问欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，乐鑫官方给的ESP8266 Demo怎么裁剪成我们要的样子以及编译。&lt;/p&gt;
&lt;h2 id=&quot;模板工程所需文件&quot;&gt;&lt;a href=&quot;#模板工程所需文件&quot; class=&quot;headerlink&quot; title=&quot;模板工程所需文件&quot;&gt;&lt;/a&gt;模板工程所需文件&lt;/h2&gt;&lt;p&gt;由于官方给的工程是包含了全部的Demo和库所以我们直接使用是不能编译的。我们就从一个最基础的工程模板开始裁剪，因为其他的功能都可以通过工程模板添加库和代码来实现。首先亮一下官方原版的RTOS SDK的工程结构(下左图)。&lt;br&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266工程的导入</title>
    <link href="http://begild.top/article/6b9c1836.html"/>
    <id>http://begild.top/article/6b9c1836.html</id>
    <published>2018-01-22T12:32:57.000Z</published>
    <updated>2018-04-26T05:14:41.994Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。</p><h2 id="准备一个SDK工程"><a href="#准备一个SDK工程" class="headerlink" title="准备一个SDK工程"></a>准备一个SDK工程</h2><ul><li>既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。</li><li>ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。</li></ul><a id="more"></a><table><tr><th width="15%">SDK类型</th><th width="55%">描述</th><th width="30%">优缺点</th></tr><tr><td>NOn-OS SDK</td><td>1.主要使⽤定时器和回调函数的⽅式实现各个功能事件的嵌套，达到特定条件下触发特定功能函数的⽬的。<br>2.使⽤ espconn 接⼝实现⽹络操作，⽤户需要按照 espconn 接⼝的使⽤规则进⾏软件开发.</td><td>1.无系统，顺序执行好理解占用资源少，但是不能有while(1);<br>2.不能有超过10ms的阻塞(延时)发生，否则将会重启。</td></tr><tr><td>RTOS SDK</td><td>1.用户可以使⽤FreeRTOS 的标准接⼝实现资源管理、循环操作、任务内延时、任务间信息传递和同步等⾯向任务流程的设计⽅式;<br>2.⽹络操作接⼝是标准 lwIP API，同时提供了 BSD Socket API 接⼝的封装实现，⽤户可以直接按照 Socket API 的使⽤⽅式来开发软件应⽤，也可以直接编译运⾏其他平台的标准 Socket 应⽤; <br>3.引⼊了 cJSON 库，使⽤该库函数可以更加⽅便的实现对 JSON 数据包的解析;<br>4.兼容 non-OS SDK 中的 Wi-Fi 接⼝、SmartConfig 接⼝、Sniffer 相关接⼝、系统接⼝、定时器接⼝、FOTA 接⼝和外围驱动接⼝，不⽀持 AT 实现。</td><td>1.有系统，通过任务的调度完成系统的运行，可以有延时。<br>2.但是资源占用较多。</td></tr></table> <ul><li>例子可以从乐鑫官方的<a href="http://espressif.com/zh-hans/support/download/sdks-demos" target="_blank" rel="noopener">下载地址</a>下载.在下图所在的网页上面有选项选择ESP8266EX之后可以从下图所示的界面选择你所需要的SDK。<br><img src="https://s1.ax1x.com/2018/01/22/p4Iub8.md.png" alt="乐鑫SDK下载"></li><li>点击右边的下载按钮会跳转到GitHub(需要你懂一点点的git的知识才能下载)。如果实在没办法的话(求求你学一点git吧)，我把我写文章的时候的最新的上传到网盘，大家可以去下载 链接: <a href="https://pan.baidu.com/s/1c39VpXQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1c39VpXQ</a> 密码: dup8 。</li><li>下载下来解压到你想放置的目录，不要有中文和(空格?)，这样工程就完成了初步的布置。接下来就是重头戏了。<h2 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h2></li><li>第一步:应该能想到吧，那就是打开Eclipe_IDE(不会打开就算了你不适合用电脑)。</li><li>第二步:打开eclipse之后会出现欢迎界面:”Welcome to the Eclipse IDE for C/C++ Developers”。</li><li>第三步:点击 工具栏-&gt;File-&gt;Import (如图)进入导入工程窗口。<br><img src="https://s1.ax1x.com/2018/01/22/p5SChq.png" alt="导入工程1"></li><li>第四步:在select窗口选择C/C++-&gt;Existing Code as Makefile Project-&gt;点击Next进行下一步<br><img src="https://s1.ax1x.com/2018/01/22/p5ptMT.png" alt="导入工程2"></li><li>第五步:Import Existing Code 窗口选择浏览你的工程路径(就是解压出来的文件的路径)-&gt;下方选择 Cygwin GCC 工具-&gt;再点击Finish按钮完成导入。如果在这一步发现没有Cygwin GCC选项回头去检查是否用Eclipse_IDE.exe选择了正确的 Cygwin 路径。<br><img src="https://s1.ax1x.com/2018/01/23/p5AYtg.png" alt="导入工程3"></li><li>第六步:这时候你会发现，什么都没出现！怎么办？，那就是把欢迎界面叉掉！这样在右边Project栏就能发现一个折叠的工程，点击可以展开，整个界面大致如下图。我的因为是用git直接克隆下来的，所以在工程名旁边会提示橙色的字。如果你是从百度云下载的那就没有，这个无需理会，都一样(牛逼吧，git)。这时候问题输出窗口应该是什么都没有的，如果提示什么找不到g++、make等等，返回去检查是否选择的工具是Cygwin GCC！！！。<br><a href="https://imgchr.com/i/p5ERIS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/01/23/p5ERIS.png" alt="工程整体结构图"></a><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>我们都是用别人的工程(Demo)上开发的，所以这一步属于比较基础的，我们导入进来之后应该是编译通不过的！为什么，因为我们的SDK路径和写Demo的人不一样。这个涉及到makefile的编写了，不过别人已经把整个makefile编写的比较”智能”了，我们只是想要编译成功的话其实是不需要懂makefile的。我们改一改SDK的路径就行了。这个下一节再讲。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>乐鑫官方的快速上手指导文档在上一篇<esp8266开发环境搭建>-&gt;后记 里有网盘链接在这里就不放了。里面有SDK文件目录的讲解7/31页，看一下便于后面理解。  我整理了一下：  </esp8266开发环境搭建></p><ol><li>RTOS SDK工程目录讲解    <ul><li>bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。  </li><li>documents：SDK 相关的⽂档(RTOS api)或链接。  </li><li>driver_lib：乐鑫官方提供的驱动示例代码。(IIC SPI GPIO等)  </li><li>examples：可供用户二次开发的示例代码。(我们把不要的删掉)  <ul><li>openssl_demo：乐鑫官方提供的 OpenSSL 接口功能示例代码。  </li><li>project_template：乐鑫官方提供的工程模板示例代码。(我们用这个，其他的以后再说)  </li><li>smart_config：乐鑫官⽅提供的 SmartConfig 功能示例代码。  </li><li>spiffs_test：乐鑫官方提供的 SPIFFS 文件系统功能示例代码。  </li><li>websocket_demo：乐鑫官方提供的 WebSocket 功能示例代码。  </li></ul></li><li>include：SDK 自带头文件，包含了用户可使⽤的相关 API 函数及其他宏定义，用户无需修改。  </li><li>ld：链接时所需的脚本文件，如⽆特殊需求，用户无需修改。(根据这个可以生成多钟bin文件)  </li><li>lib：SDK 提供的库文件。(只能用api不能改不能看)  </li><li>third_party：乐鑫开放源代码的第三方库，当前包含FreeRTOS、JSON、LWIP,mbedTLS、noPoll、OpenSSL、SPIFFS 和 SSL。  </li><li>tools：编译 BIN 文件所需的工程具，用户无需修改。  </li></ul></li><li>Non-OS SDK工程目录讲解  <ul><li>bin：编译⽣成的 BIN 文件，可直接下载到 Flash 中。  </li><li>documents：SDK 相关的⽂档或链接。  </li><li>driver_lib：外设驱动的库文件，如：UART、I2C 和 GPIO 等。  </li><li>examples：可供用户次开发的示例代码，如 IoT Demo 等。   </li><li>include：SDK ⾃带头文件，包含了用户可使用的相关 API 函数及其他宏定义，用户无需修改。  </li><li>ld：链接时所需的脚本文件，若无特殊需求，用户⽆需修改。  </li><li>lib：SDK 提供的库文件。  </li><li>tools：编译 BIN 文件所需的工具，用户无需修改。  </li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，ESP8266的工程怎么导入到Eclipse里。&lt;/p&gt;
&lt;h2 id=&quot;准备一个SDK工程&quot;&gt;&lt;a href=&quot;#准备一个SDK工程&quot; class=&quot;headerlink&quot; title=&quot;准备一个SDK工程&quot;&gt;&lt;/a&gt;准备一个SDK工程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;既然是导入那么你首先得有一个现有的工程(不存在建工程的，这辈子都不可能徒手建工程的)，工程从网上找一个就OK了。&lt;/li&gt;
&lt;li&gt;ESP8266的SDK有两种，一种是无系统(NON-OS SDK)，另一种是运行了FreeRTOS的(RTOS SDK)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266开发环境的搭建</title>
    <link href="http://begild.top/article/5bce99c.html"/>
    <id>http://begild.top/article/5bce99c.html</id>
    <published>2018-01-21T13:54:35.000Z</published>
    <updated>2018-08-27T15:28:28.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇文章主要讲一下，ESP8266的开发环境怎么搭建。</p><h2 id="开发工具下载"><a href="#开发工具下载" class="headerlink" title="开发工具下载:"></a>开发工具下载:</h2><p>对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。<a href="http://pan.baidu.com/s/1skRvR1j" target="_blank" rel="noopener">点击这里</a>下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：<a href="https://pan.baidu.com/s/1c3OitUw" target="_blank" rel="noopener">ESP8266开发环境</a> 密码: qnkh。如果我的失效了请联系我更换。</p><h2 id="开发环境搭建步骤"><a href="#开发环境搭建步骤" class="headerlink" title="开发环境搭建步骤"></a>开发环境搭建步骤</h2><p>当你忍受了百度云限速下载完成后恭喜你最<font color="#00ffff" size="5">艰难</font>的一步完成！下载之后的会有四个文件：<br><a id="more"></a><br>文件     |说明<br>—    |—<br>cygwin.exe | cygwin和xtensa编译器环境<br>Eclipse.exe | eclipse c/c++ 开发工具打包<br>ESP_IDE.exe | 一体化开发环境(配置)工具<br>下载前读我！！！.txt|就是说明文档和教程(我的教程意义何在!!!)</p><ol><li>我们要把下载的文件放到你想要放的位置该位置必须<font color="#ff0000" size="5">不能有空格</font>(cygwin目录不能有空格)，我一开始放在了放在了”D:\Program Files\ESP8266IDE\” 目录下导致后面没法选择 cygwin。最后我选择放在 “D:\ESP8266IDE\”，</li><li>点击打开cygwin.exe和Eclipse.exe进行自解压到当前目录，解压完成之后会在生成两个目录，”cygwin 和 eclipse”。</li><li>点击ESP_IDE.exe运行，选择cygwin目录和eclipse目录。同时右下角的Not Ask也勾选，这样下次就不会再次弹出来让你选择path。如果出问题了删除ESP_IDE.exe同级目录-&gt;config-&gt;cfg.xml，再次打开就会提示你选择。<br><img src="https://s1.ax1x.com/2018/01/21/pfHHkF.png" alt="选择工具路径"></li><li>首次运行会提示选择工作空间的路径。自己建一个目录选择就OK了,我选择”D:\ESP8266IDE\workspaces”,勾选下面的选项下次就不会弹出来让你选了。(备注：一个工作空间可以同时打开很多个工程，不是每一个工程都需要打开一次IDE)。<br><img src="https://s1.ax1x.com/2018/01/21/pfHbY4.png" alt="选择工作空间">  </li></ol><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>这样就完成了开发环境的配置了，是不是感觉有点简单的过分。把cygwin.exe、Eclipse.exe删除节省空间。最后，别忘了把ESP_IDE.exe创建一个快捷方式到桌面(不懂的…)，这样你下次直接点击就能打开eclipseIDE了。  </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>还有另外一种使用ubuntu镜像进行编译的方式，不过没有这种方便所以就不介绍了(官方有一个文档可自行去乐鑫下载也可下载我上传到网盘的链接:<a href="https://pan.baidu.com/s/1ggMazRl" target="_blank" rel="noopener">https://pan.baidu.com/s/1ggMazRl</a> 密码: g3y3 ,在第9/31页开始讲。所以感谢<a href="https://www.ai-thinker.com" target="_blank" rel="noopener">安信可公司</a>的奉献，让我们可以省去使用官方ubuntu镜像编译的开发方式！撒花ing…</li><li>arduino IDE工具，这个也可以开发，不过我并不喜欢arduino所以我一眼都没看过23333。  </li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>乐鑫公司官方文档资料、工具、demo下载地址:<a href="http://espressif.com/zh-hans/support/download/overview" target="_blank" rel="noopener">http://espressif.com/zh-hans/support/download/overview</a>.</li><li>安信可公司官方的资料地址:<a href="http://wiki.ai-thinker.com/esp8266" target="_blank" rel="noopener">http://wiki.ai-thinker.com/esp8266</a>.</li><li>开发快公司提供免费的ESP8266模组的申请:<a href="http://bbs.kaifakuai.com/thread-981-1-1.html" target="_blank" rel="noopener">http://bbs.kaifakuai.com/thread-981-1-1.html</a>,注册之后就可以申请(我当时就是因为申请到了才开始玩ESP8266的，虽然很便宜但是抵不住他不要钱啊！！！).当然他们公司资料也很多的也很活跃，大家可以到处逛逛。开发快官方开发平台:<a href="http://developer.kaifakuai.com" target="_blank" rel="noopener">http://developer.kaifakuai.com</a>。QQ群:445880047。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;本篇文章主要讲一下，ESP8266的开发环境怎么搭建。&lt;/p&gt;
&lt;h2 id=&quot;开发工具下载&quot;&gt;&lt;a href=&quot;#开发工具下载&quot; class=&quot;headerlink&quot; title=&quot;开发工具下载:&quot;&gt;&lt;/a&gt;开发工具下载:&lt;/h2&gt;&lt;p&gt;对于ESP8266的开发工具我们采用的是eclipse搭建的一个IDE。这是安信可公司开发出来的，他们公司还出了一款付费的，只需要点一点就能生成基础代码的工具(不付费只能生成代码不能编译)。&lt;a href=&quot;http://pan.baidu.com/s/1skRvR1j&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;下载最新的IDE。这里最新更新是2016年，应该已经停止了更新。防止链接失效，我转存到我的网盘：&lt;a href=&quot;https://pan.baidu.com/s/1c3OitUw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ESP8266开发环境&lt;/a&gt; 密码: qnkh。如果我的失效了请联系我更换。&lt;/p&gt;
&lt;h2 id=&quot;开发环境搭建步骤&quot;&gt;&lt;a href=&quot;#开发环境搭建步骤&quot; class=&quot;headerlink&quot; title=&quot;开发环境搭建步骤&quot;&gt;&lt;/a&gt;开发环境搭建步骤&lt;/h2&gt;&lt;p&gt;当你忍受了百度云限速下载完成后恭喜你最&lt;font color=&quot;#00ffff&quot; size=&quot;5&quot;&gt;艰难&lt;/font&gt;的一步完成！下载之后的会有四个文件：&lt;br&gt;
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP8266开发历程前言</title>
    <link href="http://begild.top/article/c1690bc8.html"/>
    <id>http://begild.top/article/c1690bc8.html</id>
    <published>2018-01-21T06:43:23.000Z</published>
    <updated>2018-04-26T05:14:41.995Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h2><p>这算是第一个教程吧，ESP8266从大三到现在学了到现在，但是没有什么记录。回头又得拿着代码一点一点看，所以打算记录一下。同时也会兼顾一些解释和教程性质的东西，给能找到这的人看看吧，希望能给你一点帮助。</p><h2 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h2><p>更新的话，不定时。至于内容的顺序，就先按照一个hello world的实现来写，从引脚，IDE，下载工具，接线到写hello world，到下载查看。这些讲完的话打开你也就懂怎么做了。但是我不会写IO的使用因为我觉得他的定位作为wifi芯片比较好，就不要掺杂其他的的东西了(个人看法)。后面的软件层面的实现(主要是网络通信的应用)的话，也会写一部分。不过感觉网上其实挺多的教程(比较零散)，所以不排除会直接把比较好的搬运过来然后配合自己的理解说一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ESP8266" scheme="http://begild.top/categories/ESP8266/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统目录讲解</title>
    <link href="http://begild.top/article/888300cc.html"/>
    <id>http://begild.top/article/888300cc.html</id>
    <published>2017-12-06T12:45:30.000Z</published>
    <updated>2018-04-26T05:14:42.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="bin-目录"><a href="#bin-目录" class="headerlink" title="/bin 目录"></a>/bin 目录</h2><ul><li>全称：Binary(Binaries)</li><li>作用：存放二进制可执行文件，例如命令行的cp命令。</li><li>备注：/bin下的命令是所有用户都可以执行的。/sbin(Spuer Binary)目录下的命令只有超级用户权限才能执行，比如分区操作。</li></ul><hr><h2 id="boot-目录"><a href="#boot-目录" class="headerlink" title="/boot 目录"></a>/boot 目录</h2><ul><li>全称 ：Boot</li><li>作用 ：存放操作系统的引导启动需要的文件。一般100M左右(50~200)。</li><li>备注 ：里面存放的vmlinuz…文件就是操作系统的内核文件，他名字就是版本号。通过bash运行 uname -r<br>可以看到系统的版本。grub引导同样在/boot下。</li></ul><hr><h2 id="dev-目录"><a href="#dev-目录" class="headerlink" title="/dev 目录"></a>/dev 目录</h2><ul><li>全称 ：Device</li><li>作用 ：把计算机的硬件抽象为文件存储在/dev下面。诸如硬盘(hd×),处理器(cpu),网卡(net),usb等等。</li></ul><hr><h2 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc 目录"></a>/etc 目录</h2><ul><li>全称 ：Etcetera(其他)/Editable Text Configuration(可编辑配置文本)</li><li>作用 ：保存几乎所有的配置文件，系统的各个服务、组件、软件的配置文件存放地方，一般以.cnf或.conf结尾(configure)。</li></ul><hr><h2 id="home-目录"><a href="#home-目录" class="headerlink" title="/home 目录"></a>/home 目录</h2><ul><li>全称 ：Home</li><li>作用 ：存放除root用户之外所有用户的’家目录’的目录。<ul><li>也就是每一个用户都会在/ｈome下有一个对应用户名的目录，用于存放该用户的私有数据。比如系统里有一个begild用户，那么/home下必有一个Beild文件夹。/home/begild下存放自己的桌面、文档等。</li></ul></li></ul><hr><h2 id="lib-目录"><a href="#lib-目录" class="headerlink" title="/lib 目录"></a>/lib 目录</h2><ul><li>全称 ：Library(Libraries)</li><li>作用 ：linux系统运行需要的共享库文件，相当于windows的.DLl文件(动态链接库)。一般以 .so (shared object)结尾。</li><li>备注：同样的还有/lib32、/lib64两个文件夹，作用和/lib相同，只是运用于32位还是64位。</li></ul><hr><h2 id="lost-found-目录"><a href="#lost-found-目录" class="headerlink" title="/lost+found　目录"></a>/lost+found　目录</h2><ul><li>全称 ：lost+found</li><li>作用 ：用于存放系统发生错误的时候遗失的文件。</li><li>备注 ：只有root权限才能访问</li></ul><hr><h2 id="mnt-目录"><a href="#mnt-目录" class="headerlink" title="/mnt 目录"></a>/mnt 目录</h2><ul><li>全称 ：Mount(挂载)</li><li>作用 ：其他文件系统挂载的挂载点。使用mount命令挂载(手动挂载)。</li><li>备注 ：具备同样作用的还有/media目录，不过media目录一般用于实现自动挂载。</li></ul><hr><h2 id="opt-目录"><a href="#opt-目录" class="headerlink" title="/opt　目录"></a>/opt　目录</h2><ul><li>全称 ：Optional application software packages(可选的应用程序)</li><li>作用 ：存放第三方、大型、版权保护的软件、游戏。</li><li>备注 ：安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。</li></ul><hr><h2 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc 目录"></a>/proc 目录</h2><ul><li>全称 ：</li><li>作用 ：存放进程信息，内核信息，内存使用等等快速变化的’文件’的目录。</li><li>备注 ：它本身不存在于实际的文件系统里。他是一种虚拟的文件系统。例如我们通过cat /proc/cpuinfo命令可以打开cpuinfo文件。里面完整的描述了cpu的信息。</li></ul><hr><h2 id="root-目录"><a href="#root-目录" class="headerlink" title="/root 目录"></a>/root 目录</h2><ul><li>全称 ：Root</li><li>作用 ：root用户的家目录，其他的用户家目录位于/home下。</li></ul><hr><h2 id="tmp-目录"><a href="#tmp-目录" class="headerlink" title="/tmp 目录"></a>/tmp 目录</h2><ul><li>全称 ：temp</li><li>作用 ：存放系统的临时文件,例如压缩文件预览.关机会自动清理,手动清理用tmpwatch命令.</li></ul><hr><h2 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a>/usr 目录</h2><ul><li>全称 ：unix software resource</li><li>作用 ：软件安装的目录.</li></ul><hr><h2 id="var-目录"><a href="#var-目录" class="headerlink" title="/var 目录"></a>/var 目录</h2><ul><li>全称 ：variable</li><li>作用 ：存放系统/软件运行过程中产生的缓存,登录日志等等文件.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="http://begild.top/categories/linux/"/>
    
    
      <category term="linux目录" scheme="http://begild.top/tags/linux%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C函数指针</title>
    <link href="http://begild.top/article/364cc1f5.html"/>
    <id>http://begild.top/article/364cc1f5.html</id>
    <published>2017-10-28T02:59:10.000Z</published>
    <updated>2018-04-26T05:14:41.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们看到如下所示的代码怎么去理解它的意义呢。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* ( <span class="keyword">void</span> (*) () ) <span class="number">0</span>) ()</span><br></pre></td></tr></table></figure></p><p>解析这个函数需要下面几个知识</p><ol><li><p>函数申明包含返回值，函数名，参数列表。</p><ul><li>如返回值是’int’ 函数名为’fun’,参数列表为’void’。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数指针和返回值为指针的函数</p><ul><li>函数指针:函数指针pfun指向的是一个返回值为int类型，参数列表为空的函数。只要是符合这个’形状’的函数都可以吧地址赋给pfun。</li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pfun) (<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li><li><p>返回值为指针的函数:返回值为int*类型的指针，参数列表为空的函数fun1。它表示fun1是一个确定的函数。不像pfun是可以指向任何符合模板的函数。</p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun1</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>所以在书写的时候必须注意是否需要加括号。</p></li><li><p>类型转化符。就像我们平时说的怎么把一个int强制转化为char呢，就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">char</span> b = (<span class="keyword">char</span>) a;</span><br></pre></td></tr></table></figure><p>我们怎么构建一个类型转化符呢，就是把目标类型用括号括起来，那么一个函数模板的类型转化符是怎么样的呢，就是把函数名去掉，然后用括号把他括起来。比如上面的函数指针pfun这个模板。我们只需要将pfun去掉，然后把剩下部分括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> (*) (<span class="keyword">void</span>) )</span><br></pre></td></tr></table></figure><p>这就是一个返回值为int参数列表为空的函数指针的强制类型转化符。</p></li></ol><hr><p>完成上述理解之后，我们着手理解一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* ( <span class="keyword">void</span> (*) () ) <span class="number">0</span>) ()</span><br></pre></td></tr></table></figure></p><p>首先通过下面这个式子可以看出这是一个函数的调用，那么左括号里面的就是函名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(       funname     ) ()</span><br></pre></td></tr></table></figure></p><p>也就是 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* (<span class="keyword">void</span> (*) () ) <span class="number">0</span>   == funname</span><br></pre></td></tr></table></figure></p><p>把0强制类型转化为void (*) () 型的函数指针。也就是指向函数地址为0的指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> (*) () ) <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="指针" scheme="http://begild.top/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>测试编译器是否支持嵌套注释</title>
    <link href="http://begild.top/article/a56a64b5.html"/>
    <id>http://begild.top/article/a56a64b5.html</id>
    <published>2017-09-30T16:16:47.000Z</published>
    <updated>2018-09-02T09:11:53.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。</p><p>提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。</p><p>出自——《C陷阱与缺陷》练习1-1</p><a id="more"></a><p>嵌套注释：顾名思义就是注释里嵌套着注释。比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/</span></span><br></pre></td></tr></table></figure></p><p>对于这段代码，不同的编译器识别的结果不同：</p><p><img src="https://s1.ax1x.com/2017/10/01/13Ezn.png" alt=""></p><p>我们如何通过代码的输出判定编译器是否支持嵌套注释呢，重点就是让同一段代码，支持嵌套注释的编译器和不支持嵌套注释的编译器注释掉不同的地方。根据题目的提示字符串中的 /* 是属于字符串的一部分，比如 “/*aa*/“ 这里面的注释标号编译器是不会理会的，而 /*“aa*“/ 这里面的 “aa” 是不会识别为字符串的。还有一点无论是 “ “ 还是 /**/都是就近匹配的。</p><ul><li><ol><li>我们首先构建一个嵌套的注释，这个注释在<strong>支持</strong>嵌套注释的编译器里能编译通过，而在<strong>不支持</strong>的编译器里编译失败：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p>不支持的系统中出现了”*/“导致编译失败</p><p><img src="https://s1.ax1x.com/2017/10/01/13Ezn.png" alt=""></p><ul><li><ol><li>我们通过添加一个 “ 使得不支持的系统编译成功<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13KdU.png" alt=""></p><ul><li><ol><li>可以看出这样添加之后不支持的编译器已经能编译成功并且有输出一字符串，支持的系统由于多了一个 “ 导致编译失败，根据题目提示我们构建一个字符串”  “并且”/*,*/“ 两两配对，所以我们添加一个 /*形成”/*“<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13MoF.png" alt=""></p><ul><li><ol><li>这样操作之后支持/不支持的编译器输出不同的字符串(蓝色部分),但是不支持的编译器多了 /* “编译失败，而它刚好又是多行注释的头,所以我们得加一个尾 */ 使得他们配对。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"*/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/13li4.png" alt=""></p><ul><li><ol><li>我们从上图可以看出不支持嵌套注释的编译器已经能通过编译并且有区别去支持嵌套注释的编译器的输出。但是支持嵌套注释的编译器由于多了*/导致编译失败，因为不支持嵌套注释的编译器的注释之间无论是什么都可以忽略，所以我们在最后的   */ 之前加一个 /* 让支持嵌套注释的编译器能找到配对的注释对。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"/**/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><img src="https://s1.ax1x.com/2017/10/01/131JJ.png" alt=""></p><p>通过上述步骤我们找到了一个合适的语句使得在两种编译器中编译成功并且有不同的输出。</p><p><img src="https://s1.ax1x.com/2017/10/01/133W9.png" alt=""></p><p>通过一段简单的代码我们可以看下效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISSupNestComment</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This compiler %s support nested comment \r\n"</span>,</span><br><span class="line">           ISSupNestComment()? <span class="string">""</span>: <span class="string">"does not"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISSupNestComment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *Str=<span class="comment">/*"/*"*/</span><span class="string">"*/"</span><span class="comment">/*"/**/</span>;</span><br><span class="line">    <span class="keyword">if</span>(Str[<span class="number">0</span>]==<span class="string">'*'</span>)<span class="comment">//"*/"不支持嵌套注释</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">//"/*"支持嵌套注释</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己做完这个感觉还是有点意思的，上网搜了一波，发现别人想的更是精妙。不禁发出一套赞赏三连，卧槽牛逼666。下面我们看下一大佬们是怎么做的。</p><h1 id="1-Doug-McIlroy"><a href="#1-Doug-McIlroy" class="headerlink" title="1.Doug McIlroy"></a>1.Doug McIlroy</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*/*/</span><span class="number">0</span>*<span class="comment">/**/</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p> 这个解法主要利用了编译器作词法分析时的“大嘴法”规则。编译器支持嵌套注释，则上式将被解释为<strong>1</strong>.编译器不支持嵌套注释，则上式将被解释为 <strong>0*1</strong>.</p><p><img src="https://s1.ax1x.com/2017/10/01/135Wj.png" alt=""></p><h1 id="2-TimWu"><a href="#2-TimWu" class="headerlink" title="2.TimWu"></a>2.<a href="http://www.cppblog.com/Tim/archive/2011/03/25/142726.html" target="_blank" rel="noopener">TimWu</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A <span class="comment">/* aaa /* a*/</span> a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanNesting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他利用的多行注释和宏定义的特性，编译器支持嵌套注释宏定义B则会被注释掉导致没有宏定义B。编译器不支持嵌套注释，宏定义B则会定义为 */。通过预编译判断就可以输出结果。</p><p><img src="https://s1.ax1x.com/2017/10/01/13OTU.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：某些C编译器允许嵌套注释。请写一个测试程序，要求：无论是对允许嵌套注释的编译器，还是对不允许嵌套注释的编译器，该程序都能正常通过编译（无错误消息出现）， 但是这两种情况下程序执行的结果却不相同。&lt;/p&gt;
&lt;p&gt;提示： 在用双引号括起的字符串中， 注释符 /* 属于字符串的一部分，而在注释中出现的双引号 “ “ 又属于注释的一部分。&lt;/p&gt;
&lt;p&gt;出自——《C陷阱与缺陷》练习1-1&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="嵌套注释" scheme="http://begild.top/tags/%E5%B5%8C%E5%A5%97%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>处理器大小端存储模式</title>
    <link href="http://begild.top/article/c25386f8.html"/>
    <id>http://begild.top/article/c25386f8.html</id>
    <published>2017-09-13T09:01:49.000Z</published>
    <updated>2018-04-26T05:14:42.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大端模式：是指数据的<strong>高字节</strong>保存在内存的<strong>低地址</strong>中，而数据的<strong>低字节</strong>保存在内存的<strong>高地址</strong>中。</p><p>小端模式：是指数据的<strong>高字节</strong>保存在内存的<strong>高地址</strong>中，而数据的<strong>低字节</strong>保存在内存的<strong>低地址</strong>中。</p><p>例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表：</p><table><thead><tr><th>内存地址</th><th>0x1000</th><th>0x1001</th><th>0x1002</th><th>0x1003</th></tr></thead><tbody><tr><td>大端模式</td><td>0x12</td><td>0x34</td><td>0x56</td><td>0x78</td><td></td></tr><tr><td>小端模式</td><td>0x78</td><td>0x56</td><td>0x34</td><td>0x12</td><td></td></tr></tbody></table><p>我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&gt;低位而地址则是低位-&gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。</p><a id="more"></a><p>利用下面c代码可以看到运行环境是如何存储一个uint数据的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> arg[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *ap=&amp;a;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x storage in system is:\r\n"</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"addr:0x%x,value:0x%x\r\n"</span>,ap+i,ap[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system storage by %s_endian"</span>,endian()? <span class="string">"Big"</span>:<span class="string">"Little"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果如下，可以看出该系统是小端系统。</p><p><a href="https://imgchr.com/i/1Mp4A" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2017/10/01/1Md81.png" alt=""></a></p><p>我们如何简单的判断一个系统的大小端呢。我们知道<strong>共用体(联合体)</strong>存储在内存里是共用一块地址的，其占用空间决定于最大成员所需的空间,他们的起始地址相同。所以我们可以利用一个共用体,成员分别是一个int和一个char。通过给int赋值1，然后检测char对应的值是多少，如果是1代表系统将数据1放到了int的起始地址(因为char是一个字节必然在起始地址)。而起始地址是低地址，低地址存放的1(权值小)推出该系统是小端系统。否则该系统是大端系统。</p><p>C代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">    &#125;endunion;</span><br><span class="line">    endunion.a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(endunion.b==<span class="number">1</span>)<span class="comment">//如果成员b是1则证明随地址顺序和数字权值顺序相同是小端模式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//小端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//大端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以用一个更加简洁的办法(原理都是检测int的起始地址存放的是什么值)，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(*((<span class="keyword">char</span> *)&amp;a));<span class="comment">//取a的地址，将其强制转化为char指针，然后取出该地址存放的值并取反;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大端模式：是指数据的&lt;strong&gt;高字节&lt;/strong&gt;保存在内存的&lt;strong&gt;低地址&lt;/strong&gt;中，而数据的&lt;strong&gt;低字节&lt;/strong&gt;保存在内存的&lt;strong&gt;高地址&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;小端模式：是指数据的&lt;strong&gt;高字节&lt;/strong&gt;保存在内存的&lt;strong&gt;高地址&lt;/strong&gt;中，而数据的&lt;strong&gt;低字节&lt;/strong&gt;保存在内存的&lt;strong&gt;低地址&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;例如：一个数据无符号32位整数0x12345678,其中0x12属于高字节(权值大)而0x78属于低字节(权值小),在不同的模式下存储的方式如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内存地址&lt;/th&gt;
&lt;th&gt;0x1000&lt;/th&gt;
&lt;th&gt;0x1001&lt;/th&gt;
&lt;th&gt;0x1002&lt;/th&gt;
&lt;th&gt;0x1003&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;大端模式&lt;/td&gt;
&lt;td&gt;0x12&lt;/td&gt;
&lt;td&gt;0x34&lt;/td&gt;
&lt;td&gt;0x56&lt;/td&gt;
&lt;td&gt;0x78&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小端模式&lt;/td&gt;
&lt;td&gt;0x78&lt;/td&gt;
&lt;td&gt;0x56&lt;/td&gt;
&lt;td&gt;0x34&lt;/td&gt;
&lt;td&gt;0x12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以看得出来大端模式和我们的阅读习惯相同，权值从左往右是高位-&amp;gt;低位而地址则是低位-&amp;gt;高位。小端模式则是随着地址从左往右增大权值增大。地址就代表了权值的大小。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="http://begild.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="大小端存储" scheme="http://begild.top/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
